   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"main.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.print_byte,"ax",%progbits
  19              		.align	2
  20              		.global	print_byte
  21              		.thumb
  22              		.thumb_func
  24              	print_byte:
  25              	.LFB0:
  26              		.file 1 "_printf.c"
   1:_printf.c     **** /******************************************************************************
   2:_printf.c     ****  * @file      main.c
   3:_printf.c     ****  * @author    SmartRobot : e2g1234@naver.com
   4:_printf.c     ****  * @version   V0.1
   5:_printf.c     ****  * @date      04/15/2013
   6:_printf.c     ****  *******************************************************************************/
   7:_printf.c     **** 
   8:_printf.c     **** void SerialOutputString(const char *s);
   9:_printf.c     **** 
  10:_printf.c     **** void        printf(char *fmt, ...);
  11:_printf.c     **** static void PrintChar(char *fmt, char c);
  12:_printf.c     **** static void PrintDec(char *fmt, int value);
  13:_printf.c     **** static void PrintHex(char *fmt, int value);
  14:_printf.c     **** static void PrintString(char *fmt, char *cptr);
  15:_printf.c     **** static int  Power(int num, int cnt);
  16:_printf.c     **** #define SWAP8(A)                (A)
  17:_printf.c     **** #define SWAP16(A)               ((((A)&0x00ff)<<8) | ((A)>>8))
  18:_printf.c     **** #define SWAP32(A)               ((((A)&0x000000ff)<<24) | (((A)&0x0000ff00)<<8) | (((A)&0x00ff0000)
  19:_printf.c     **** 
  20:_printf.c     **** typedef        int              bool;
  21:_printf.c     **** #define        true             1
  22:_printf.c     **** #define        false            0
  23:_printf.c     **** 
  24:_printf.c     **** 
  25:_printf.c     **** // print in hex value.
  26:_printf.c     **** // type= 8 : print in format "ff".
  27:_printf.c     **** // type=16 : print in format "ffff".
  28:_printf.c     **** // type=32 : print in format "ffffffff".
  29:_printf.c     **** typedef enum {
  30:_printf.c     ****         VAR_LONG=32,
  31:_printf.c     ****         VAR_SHORT=16,
  32:_printf.c     ****         VAR_CHAR=8
  33:_printf.c     **** } VAR_TYPE;
  34:_printf.c     **** 
  35:_printf.c     **** typedef char *va_list;
  36:_printf.c     **** #define va_start(ap, p)         (ap = (char *) (&(p)+1))
  37:_printf.c     **** #define va_arg(ap, type)        ((type *) (ap += sizeof(type)))[-1]
  38:_printf.c     **** #define va_end(ap)
  39:_printf.c     **** 
  40:_printf.c     **** 
  41:_printf.c     **** 
  42:_printf.c     **** void print_byte(unsigned int c)
  43:_printf.c     **** {
  27              		.loc 1 43 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  44:_printf.c     ****     if (c == '\n') print_byte('\r');
  32              		.loc 1 44 0
  33 0000 0A28     		cmp	r0, #10
  43:_printf.c     **** {
  34              		.loc 1 43 0
  35 0002 10B5     		push	{r4, lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 8
  38              		.cfi_offset 4, -8
  39              		.cfi_offset 14, -4
  43:_printf.c     **** {
  40              		.loc 1 43 0
  41 0004 0446     		mov	r4, r0
  42              		.loc 1 44 0
  43 0006 06D0     		beq	.L6
  44              	.LVL1:
  45              	.L2:
  45:_printf.c     ****     while( !((*(volatile unsigned long *) 0x40013800) & 0x80) ) ;
  46              		.loc 1 45 0 discriminator 1
  47 0008 054A     		ldr	r2, .L7
  48              	.L4:
  49 000a 1368     		ldr	r3, [r2]
  50 000c 1B06     		lsls	r3, r3, #24
  51 000e FCD5     		bpl	.L4
  46:_printf.c     ****     *(volatile unsigned long *) 0x40013804 = c;
  52              		.loc 1 46 0
  53 0010 044B     		ldr	r3, .L7+4
  54 0012 1C60     		str	r4, [r3]
  55 0014 10BD     		pop	{r4, pc}
  56              	.LVL2:
  57              	.L6:
  44:_printf.c     ****     if (c == '\n') print_byte('\r');
  58              		.loc 1 44 0 discriminator 1
  59 0016 0D20     		movs	r0, #13
  60              	.LVL3:
  61 0018 FFF7FEFF 		bl	print_byte
  62              	.LVL4:
  63 001c F4E7     		b	.L2
  64              	.L8:
  65 001e 00BF     		.align	2
  66              	.L7:
  67 0020 00380140 		.word	1073821696
  68 0024 04380140 		.word	1073821700
  69              		.cfi_endproc
  70              	.LFE0:
  72              		.section	.text.get_byte,"ax",%progbits
  73              		.align	2
  74              		.global	get_byte
  75              		.thumb
  76              		.thumb_func
  78              	get_byte:
  79              	.LFB1:
  47:_printf.c     **** }
  48:_printf.c     **** 
  49:_printf.c     **** char get_byte(void)
  50:_printf.c     **** {
  80              		.loc 1 50 0
  81              		.cfi_startproc
  82              		@ args = 0, pretend = 0, frame = 0
  83              		@ frame_needed = 0, uses_anonymous_args = 0
  84              		@ link register save eliminated.
  51:_printf.c     ****     while( !((*(volatile unsigned long *) 0x40013800) & 0x20) ) ;
  85              		.loc 1 51 0
  86 0000 034A     		ldr	r2, .L12
  87              	.L11:
  88              		.loc 1 51 0 is_stmt 0 discriminator 1
  89 0002 1368     		ldr	r3, [r2]
  90 0004 9B06     		lsls	r3, r3, #26
  91 0006 FCD5     		bpl	.L11
  52:_printf.c     ****     return (char) (*(volatile unsigned long *) 0x40013804 & 0xff);
  92              		.loc 1 52 0 is_stmt 1
  93 0008 024B     		ldr	r3, .L12+4
  94 000a 1868     		ldr	r0, [r3]
  53:_printf.c     **** }
  95              		.loc 1 53 0
  96 000c C0B2     		uxtb	r0, r0
  97 000e 7047     		bx	lr
  98              	.L13:
  99              		.align	2
 100              	.L12:
 101 0010 00380140 		.word	1073821696
 102 0014 04380140 		.word	1073821700
 103              		.cfi_endproc
 104              	.LFE1:
 106              		.section	.text.SerialOutputString,"ax",%progbits
 107              		.align	2
 108              		.global	SerialOutputString
 109              		.thumb
 110              		.thumb_func
 112              	SerialOutputString:
 113              	.LFB2:
  54:_printf.c     **** 
  55:_printf.c     **** 
  56:_printf.c     **** // Write a null terminated string to the serial port.
  57:_printf.c     **** void SerialOutputString(const char *s)
  58:_printf.c     **** {
 114              		.loc 1 58 0
 115              		.cfi_startproc
 116              		@ args = 0, pretend = 0, frame = 0
 117              		@ frame_needed = 0, uses_anonymous_args = 0
 118              	.LVL5:
 119 0000 70B5     		push	{r4, r5, r6, lr}
 120              	.LCFI1:
 121              		.cfi_def_cfa_offset 16
 122              		.cfi_offset 4, -16
 123              		.cfi_offset 5, -12
 124              		.cfi_offset 6, -8
 125              		.cfi_offset 14, -4
 126              		.loc 1 58 0
 127 0002 0446     		mov	r4, r0
  59:_printf.c     ****         while (*s != 0) 
 128              		.loc 1 59 0
 129 0004 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 130              	.LVL6:
 131 0006 78B1     		cbz	r0, .L14
 132 0008 084D     		ldr	r5, .L22
 133 000a 013C     		subs	r4, r4, #1
 134              	.LVL7:
  60:_printf.c     ****         {
  61:_printf.c     ****                 print_byte(*s);
 135              		.loc 1 61 0
 136 000c 2E46     		mov	r6, r5
 137 000e 01E0     		b	.L18
 138              	.LVL8:
 139              	.L16:
  59:_printf.c     ****         while (*s != 0) 
 140              		.loc 1 59 0
 141 0010 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 142 0012 48B1     		cbz	r0, .L14
 143              	.LVL9:
 144              	.L18:
 145              		.loc 1 61 0
 146 0014 A847     		blx	r5
 147              	.LVL10:
  62:_printf.c     ****                 // If \n, also do \r.
  63:_printf.c     ****                 if (*s == '\n') print_byte('\r');
 148              		.loc 1 63 0
 149 0016 14F8013F 		ldrb	r3, [r4, #1]!	@ zero_extendqisi2
 150              	.LVL11:
 151 001a 0A2B     		cmp	r3, #10
 152 001c F8D1     		bne	.L16
 153              		.loc 1 63 0 is_stmt 0 discriminator 1
 154 001e 0D20     		movs	r0, #13
 155 0020 B047     		blx	r6
 156              	.LVL12:
  59:_printf.c     ****         while (*s != 0) 
 157              		.loc 1 59 0 is_stmt 1 discriminator 1
 158 0022 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 159 0024 0028     		cmp	r0, #0
 160 0026 F5D1     		bne	.L18
 161              	.LVL13:
 162              	.L14:
 163 0028 70BD     		pop	{r4, r5, r6, pc}
 164              	.L23:
 165 002a 00BF     		.align	2
 166              	.L22:
 167 002c 00000000 		.word	print_byte
 168              		.cfi_endproc
 169              	.LFE2:
 171              		.section	.text.StrNCmp,"ax",%progbits
 172              		.align	2
 173              		.global	StrNCmp
 174              		.thumb
 175              		.thumb_func
 177              	StrNCmp:
 178              	.LFB3:
  64:_printf.c     ****                 s++;        
  65:_printf.c     ****         }
  66:_printf.c     **** } // SerialOutputString.
  67:_printf.c     **** 
  68:_printf.c     **** // 문자열 s1, s2을 길이 len의 범위 이내에서 비교.
  69:_printf.c     **** // return : 0 : equil                ret : s1 > s2                -ret : s1 < s2
  70:_printf.c     **** int StrNCmp(char *s1, char *s2, int len){
 179              		.loc 1 70 0
 180              		.cfi_startproc
 181              		@ args = 0, pretend = 0, frame = 0
 182              		@ frame_needed = 0, uses_anonymous_args = 0
 183              		@ link register save eliminated.
 184              	.LVL14:
  71:_printf.c     ****         int i;
  72:_printf.c     **** 
  73:_printf.c     **** 
  74:_printf.c     ****         for(i = 0; i < len; i++){
 185              		.loc 1 74 0
 186 0000 002A     		cmp	r2, #0
  70:_printf.c     **** int StrNCmp(char *s1, char *s2, int len){
 187              		.loc 1 70 0
 188 0002 10B4     		push	{r4}
 189              	.LCFI2:
 190              		.cfi_def_cfa_offset 4
 191              		.cfi_offset 4, -4
 192              		.loc 1 74 0
 193 0004 10DD     		ble	.L30
  75:_printf.c     ****                 if(s1[i] != s2[i])        return ((int)s1[i]) - ((int)s2[i]);
 194              		.loc 1 75 0
 195 0006 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 196 0008 0C78     		ldrb	r4, [r1]	@ zero_extendqisi2
 197 000a A342     		cmp	r3, r4
 198 000c 10D1     		bne	.L26
  76:_printf.c     ****                 if(s1[i] == 0)                return 0;
 199              		.loc 1 76 0
 200 000e 9BB1     		cbz	r3, .L32
 201 0010 431E     		subs	r3, r0, #1
 202 0012 1A44     		add	r2, r2, r3
 203              	.LVL15:
 204 0014 06E0     		b	.L27
 205              	.LVL16:
 206              	.L29:
  75:_printf.c     ****                 if(s1[i] != s2[i])        return ((int)s1[i]) - ((int)s2[i]);
 207              		.loc 1 75 0
 208 0016 10F8013F 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 209              	.LVL17:
 210 001a 11F8014F 		ldrb	r4, [r1, #1]!	@ zero_extendqisi2
 211 001e A342     		cmp	r3, r4
 212 0020 06D1     		bne	.L26
 213              		.loc 1 76 0
 214 0022 4BB1     		cbz	r3, .L32
 215              	.LVL18:
 216              	.L27:
  74:_printf.c     ****         for(i = 0; i < len; i++){
 217              		.loc 1 74 0
 218 0024 9042     		cmp	r0, r2
 219 0026 F6D1     		bne	.L29
 220              	.LVL19:
 221              	.L30:
  77:_printf.c     ****         }
  78:_printf.c     ****         return 0;
 222              		.loc 1 78 0
 223 0028 0020     		movs	r0, #0
  79:_printf.c     **** } // StrNCmp.
 224              		.loc 1 79 0
 225 002a 5DF8044B 		ldr	r4, [sp], #4
 226 002e 7047     		bx	lr
 227              	.L26:
  75:_printf.c     ****                 if(s1[i] != s2[i])        return ((int)s1[i]) - ((int)s2[i]);
 228              		.loc 1 75 0 discriminator 1
 229 0030 181B     		subs	r0, r3, r4
 230              		.loc 1 79 0 discriminator 1
 231 0032 5DF8044B 		ldr	r4, [sp], #4
 232 0036 7047     		bx	lr
 233              	.L32:
  78:_printf.c     ****         return 0;
 234              		.loc 1 78 0
 235 0038 1846     		mov	r0, r3
 236              		.loc 1 79 0
 237 003a 5DF8044B 		ldr	r4, [sp], #4
 238 003e 7047     		bx	lr
 239              		.cfi_endproc
 240              	.LFE3:
 242              		.section	.text.StrCmp,"ax",%progbits
 243              		.align	2
 244              		.global	StrCmp
 245              		.thumb
 246              		.thumb_func
 248              	StrCmp:
 249              	.LFB4:
  80:_printf.c     **** 
  81:_printf.c     **** // 문자열 s1, s2를 비교.
  82:_printf.c     **** // return : 0 : equil                ret : s1 > s2                -ret : s1 < s2
  83:_printf.c     **** int StrCmp(char *s1, char *s2){
 250              		.loc 1 83 0
 251              		.cfi_startproc
 252              		@ args = 0, pretend = 0, frame = 0
 253              		@ frame_needed = 0, uses_anonymous_args = 0
 254              		@ link register save eliminated.
 255              	.LVL20:
 256 0000 10B4     		push	{r4}
 257              	.LCFI3:
 258              		.cfi_def_cfa_offset 4
 259              		.cfi_offset 4, -4
  84:_printf.c     ****         for (; *s1 && *s2; s1++, s2++)
 260              		.loc 1 84 0
 261 0002 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 262 0004 83B1     		cbz	r3, .L34
 263 0006 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 264 0008 AAB1     		cbz	r2, .L35
  85:_printf.c     ****         {
  86:_printf.c     ****                 if (*s1 != *s2) return ((int)(*s1) - (int)(*s2));
 265              		.loc 1 86 0
 266 000a 9342     		cmp	r3, r2
 267 000c 08BF     		it	eq
 268 000e 4C1C     		addeq	r4, r1, #1
 269 0010 05D0     		beq	.L38
 270 0012 12E0     		b	.L36
 271              	.LVL21:
 272              	.L54:
  84:_printf.c     ****         for (; *s1 && *s2; s1++, s2++)
 273              		.loc 1 84 0 discriminator 2
 274 0014 14F8012B 		ldrb	r2, [r4], #1	@ zero_extendqisi2
 275 0018 6AB1     		cbz	r2, .L35
 276              		.loc 1 86 0
 277 001a 9342     		cmp	r3, r2
 278 001c 0DD1     		bne	.L36
 279              	.LVL22:
 280              	.L38:
  84:_printf.c     ****         for (; *s1 && *s2; s1++, s2++)
 281              		.loc 1 84 0
 282 001e 10F8013F 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 283 0022 2146     		mov	r1, r4
 284              	.LVL23:
 285 0024 002B     		cmp	r3, #0
 286 0026 F5D1     		bne	.L54
 287              	.LVL24:
 288              	.L34:
  87:_printf.c     ****         }
  88:_printf.c     ****         if (*s1 || *s2) return ((int)(*s1) - (int)(*s2));
 289              		.loc 1 88 0
 290 0028 0878     		ldrb	r0, [r1]	@ zero_extendqisi2
 291 002a 08B1     		cbz	r0, .L53
 292 002c 0023     		movs	r3, #0
 293              	.L41:
 294              		.loc 1 88 0 is_stmt 0 discriminator 1
 295 002e 181A     		subs	r0, r3, r0
 296              	.L53:
  89:_printf.c     ****         return 0;
  90:_printf.c     **** }        // StrCmp.
 297              		.loc 1 90 0 is_stmt 1
 298 0030 5DF8044B 		ldr	r4, [sp], #4
 299 0034 7047     		bx	lr
 300              	.L35:
  83:_printf.c     **** int StrCmp(char *s1, char *s2){
 301              		.loc 1 83 0
 302 0036 0020     		movs	r0, #0
 303 0038 F9E7     		b	.L41
 304              	.L36:
  86:_printf.c     ****                 if (*s1 != *s2) return ((int)(*s1) - (int)(*s2));
 305              		.loc 1 86 0 discriminator 1
 306 003a 981A     		subs	r0, r3, r2
 307              		.loc 1 90 0 discriminator 1
 308 003c 5DF8044B 		ldr	r4, [sp], #4
 309 0040 7047     		bx	lr
 310              		.cfi_endproc
 311              	.LFE4:
 313 0042 00BF     		.section	.text.DecToLong,"ax",%progbits
 314              		.align	2
 315              		.global	DecToLong
 316              		.thumb
 317              		.thumb_func
 319              	DecToLong:
 320              	.LFB5:
  91:_printf.c     **** 
  92:_printf.c     **** // 역할 : 10진수 문자열 s에서 정수를 만들어 retval이 가리키는 위치에 기록.
  93:_printf.c     **** // 매개 : s      : 변환할 문자열의 주소.
  94:_printf.c     **** //        retval : 변환된 값이 기록될 주소.
  95:_printf.c     **** // 반환 : return : 1 : success                0 : failure.
  96:_printf.c     **** // 주의 :
  97:_printf.c     **** int DecToLong(char *s, long *retval){
 321              		.loc 1 97 0
 322              		.cfi_startproc
 323              		@ args = 0, pretend = 0, frame = 0
 324              		@ frame_needed = 0, uses_anonymous_args = 0
 325              		@ link register save eliminated.
 326              	.LVL25:
 327 0000 30B4     		push	{r4, r5}
 328              	.LCFI4:
 329              		.cfi_def_cfa_offset 8
 330              		.cfi_offset 4, -8
 331              		.cfi_offset 5, -4
  98:_printf.c     ****         long remainder;
  99:_printf.c     ****         if (!s || !s[0]) return false;
 332              		.loc 1 99 0
 333 0002 D0B1     		cbz	r0, .L56
 334              		.loc 1 99 0 is_stmt 0 discriminator 2
 335 0004 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 336 0006 D3B1     		cbz	r3, .L64
 337              	.LVL26:
 338              	.LBB16:
 339              	.LBB17:
 100:_printf.c     **** 
 101:_printf.c     **** 
 102:_printf.c     ****         for (*retval=0; *s; s++){
 340              		.loc 1 102 0 is_stmt 1
 341 0008 0023     		movs	r3, #0
 342 000a 0B60     		str	r3, [r1]
 343 000c 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
 344 000e 9AB1     		cbz	r2, .L62
 103:_printf.c     ****                 if (*s < '0' || *s > '9') return false;
 345              		.loc 1 103 0
 346 0010 A2F13004 		sub	r4, r2, #48
 347 0014 E2B2     		uxtb	r2, r4
 348 0016 092A     		cmp	r2, #9
 349 0018 02D9     		bls	.L60
 350 001a 13E0     		b	.L59
 351              	.LVL27:
 352              	.L61:
 353 001c 092D     		cmp	r5, #9
 354 001e 11D8     		bhi	.L59
 355              	.LVL28:
 356              	.L60:
 104:_printf.c     ****                 remainder = *s - '0';
 105:_printf.c     ****                 *retval = *retval * 10 + remainder;
 357              		.loc 1 105 0
 358 0020 03EB8303 		add	r3, r3, r3, lsl #2
 359 0024 04EB4303 		add	r3, r4, r3, lsl #1
 360 0028 0B60     		str	r3, [r1]
 361              	.LVL29:
 102:_printf.c     ****         for (*retval=0; *s; s++){
 362              		.loc 1 102 0
 363 002a 10F8012F 		ldrb	r2, [r0, #1]!	@ zero_extendqisi2
 364              	.LVL30:
 103:_printf.c     ****                 if (*s < '0' || *s > '9') return false;
 365              		.loc 1 103 0
 366 002e A2F13004 		sub	r4, r2, #48
 367 0032 E5B2     		uxtb	r5, r4
 102:_printf.c     ****         for (*retval=0; *s; s++){
 368              		.loc 1 102 0
 369 0034 002A     		cmp	r2, #0
 370 0036 F1D1     		bne	.L61
 371              	.LVL31:
 372              	.L62:
 106:_printf.c     ****         }
 107:_printf.c     ****         return true;
 373              		.loc 1 107 0
 374 0038 0120     		movs	r0, #1
 375              	.LVL32:
 376              	.L56:
 377              	.LBE17:
 378              	.LBE16:
 108:_printf.c     **** }        // DecToLong.
 379              		.loc 1 108 0
 380 003a 30BC     		pop	{r4, r5}
 381 003c 7047     		bx	lr
 382              	.LVL33:
 383              	.L64:
  99:_printf.c     ****         if (!s || !s[0]) return false;
 384              		.loc 1 99 0
 385 003e 1846     		mov	r0, r3
 386              	.LVL34:
 387              		.loc 1 108 0
 388 0040 30BC     		pop	{r4, r5}
 389 0042 7047     		bx	lr
 390              	.LVL35:
 391              	.L59:
 392              	.LBB19:
 393              	.LBB18:
 103:_printf.c     ****                 if (*s < '0' || *s > '9') return false;
 394              		.loc 1 103 0
 395 0044 0020     		movs	r0, #0
 396              	.LBE18:
 397              	.LBE19:
 398              		.loc 1 108 0
 399 0046 30BC     		pop	{r4, r5}
 400 0048 7047     		bx	lr
 401              		.cfi_endproc
 402              	.LFE5:
 404 004a 00BF     		.section	.text.printf,"ax",%progbits
 405              		.align	2
 406              		.global	printf
 407              		.thumb
 408              		.thumb_func
 410              	printf:
 411              	.LFB6:
 109:_printf.c     **** 
 110:_printf.c     **** // 역할 : printf() 중 일부를 간단하게 구현.
 111:_printf.c     **** // 매개 : fmt : printf()와 동일하나 "%s", "%c", "%d", "%x" 사용 가능.
 112:_printf.c     **** //              %d, %x의 경우에는 "%08x", "%8x"와 같이 나타낼 길이와 빈 공간을 0으로 채울지 선택 가
 113:_printf.c     **** // 반환 : 없음.
 114:_printf.c     **** // 주의 : 없음.
 115:_printf.c     **** void printf(char *fmt, ...)
 116:_printf.c     **** {
 412              		.loc 1 116 0
 413              		.cfi_startproc
 414              		@ args = 4, pretend = 16, frame = 40
 415              		@ frame_needed = 0, uses_anonymous_args = 1
 416              	.LVL36:
 417 0000 0FB4     		push	{r0, r1, r2, r3}
 418              	.LCFI5:
 419              		.cfi_def_cfa_offset 16
 420              		.cfi_offset 0, -16
 421              		.cfi_offset 1, -12
 422              		.cfi_offset 2, -8
 423              		.cfi_offset 3, -4
 424 0002 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 425              	.LCFI6:
 426              		.cfi_def_cfa_offset 52
 427              		.cfi_offset 4, -52
 428              		.cfi_offset 5, -48
 429              		.cfi_offset 6, -44
 430              		.cfi_offset 7, -40
 431              		.cfi_offset 8, -36
 432              		.cfi_offset 9, -32
 433              		.cfi_offset 10, -28
 434              		.cfi_offset 11, -24
 435              		.cfi_offset 14, -20
 436 0006 8BB0     		sub	sp, sp, #44
 437              	.LCFI7:
 438              		.cfi_def_cfa_offset 96
 117:_printf.c     ****         int i;
 118:_printf.c     ****         va_list args;
 119:_printf.c     ****         char *s=fmt;
 439              		.loc 1 119 0
 440 0008 0DF1500A 		add	r10, sp, #80
 441 000c 5AF8044B 		ldr	r4, [r10], #4
 442              	.LVL37:
 443              	.LBB36:
 444              	.LBB37:
 120:_printf.c     ****         char format[10];        // fmt의 인자가 "%08lx"라면, "08l"를 임시로 기록.
 121:_printf.c     ****         
 122:_printf.c     ****         va_start(args, fmt);
 123:_printf.c     ****         while (*s){
 124:_printf.c     ****                 if (*s=='%'){
 125:_printf.c     ****                         s++;
 126:_printf.c     ****                         // s에서 "%08lx"형식을 가져와 format에 기록. 나중에 출력함수에 넘겨줌.
 127:_printf.c     ****                         format[0] = '%';
 128:_printf.c     ****                         for (i=1; i<10;){
 129:_printf.c     ****                                 if (*s=='c' || *s=='d' || *s=='x' || *s=='s' || *s=='%'){
 130:_printf.c     ****                                         format[i++] = *s;
 131:_printf.c     ****                                         format[i] = '\0';
 132:_printf.c     ****                                         break;
 133:_printf.c     ****                                 }
 134:_printf.c     ****                                 else {
 135:_printf.c     ****                                         format[i++] = *s++;
 136:_printf.c     ****                                 }
 137:_printf.c     ****                         }
 138:_printf.c     ****                         // "%s", "%c", "%d", "%x"를 찾아 출력할 함수 호출.
 139:_printf.c     ****                         switch (*s++){
 140:_printf.c     ****                                 case 'c' :
 141:_printf.c     ****                                         PrintChar(format, va_arg(args, int));
 142:_printf.c     ****                                         break;
 143:_printf.c     ****                                 case 'd' :
 144:_printf.c     ****                                         PrintDec(format, va_arg(args, int));
 145:_printf.c     ****                                         break;
 146:_printf.c     ****                                 case 'x' :
 147:_printf.c     ****                                         PrintHex(format, va_arg(args, int));
 148:_printf.c     ****                                         break;
 149:_printf.c     ****                                 case 's' :
 150:_printf.c     ****                                         PrintString(format, va_arg(args, char *));
 151:_printf.c     ****                                         break;
 152:_printf.c     ****                                 case '%' :
 153:_printf.c     ****                                         PrintChar("%c", '%');
 154:_printf.c     ****                                         break;
 155:_printf.c     ****                         }
 156:_printf.c     ****                 }
 157:_printf.c     ****                 else {
 158:_printf.c     ****                         PrintChar("%c", *s);
 159:_printf.c     ****                         s++;
 160:_printf.c     ****                 }
 161:_printf.c     ****         }
 162:_printf.c     ****         va_end(args);
 163:_printf.c     ****         return;
 164:_printf.c     **** }
 165:_printf.c     **** 
 166:_printf.c     **** void PrintChar(char *fmt, char c)
 167:_printf.c     **** {
 168:_printf.c     ****         print_byte(c);
 445              		.loc 1 168 0
 446 0010 BF4D     		ldr	r5, .L223
 447              	.LBE37:
 448              	.LBE36:
 449              	.LBB39:
 450              	.LBB40:
 169:_printf.c     ****         return;
 170:_printf.c     **** }
 171:_printf.c     **** 
 172:_printf.c     **** void PrintDec(char *fmt, int l)
 173:_printf.c     **** {
 174:_printf.c     ****         int        i, j;
 175:_printf.c     ****         char        c, *s=fmt, tol[10];
 176:_printf.c     ****         bool        flag0=false, flagl=false;        // "%08lx"에서 '0', 'l'의 존재 여부.
 177:_printf.c     ****         long        flagcnt=0;                                        // "%08lx"에서 "8"을 찾아서 l
 178:_printf.c     ****         bool        leading_zero=true;                        // long형의 data를 출력하기 위한 변수
 179:_printf.c     ****         long        divisor, result, remainder;
 180:_printf.c     **** 
 181:_printf.c     **** 
 182:_printf.c     ****         // fmt의 "%08lx"에서 '0', '8', 'l'을 해석.
 183:_printf.c     ****         for (i=0; (c=s[i]) != 0; i++){
 184:_printf.c     ****                 if (c=='d') break;
 185:_printf.c     ****                 else if (c>='1' && c<='9'){
 186:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 187:_printf.c     ****                                 tol[j] = s[i++];
 188:_printf.c     ****                         }
 189:_printf.c     ****                         tol[j] = '\0';
 190:_printf.c     ****                         i--;
 191:_printf.c     ****                         DecToLong(tol, &flagcnt);
 451              		.loc 1 191 0
 452 0012 C04F     		ldr	r7, .L223+4
 453              	.LVL38:
 454              	.L66:
 455              	.LBE40:
 456              	.LBE39:
 123:_printf.c     ****         while (*s){
 457              		.loc 1 123 0 discriminator 1
 458 0014 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 459 0016 A0B3     		cbz	r0, .L216
 460              	.L152:
 124:_printf.c     ****                 if (*s=='%'){
 461              		.loc 1 124 0
 462 0018 2528     		cmp	r0, #37
 463 001a 37D1     		bne	.L67
 464              	.LVL39:
 127:_printf.c     ****                         format[0] = '%';
 465              		.loc 1 127 0
 466 001c 8DF81000 		strb	r0, [sp, #16]
 467              	.LVL40:
 125:_printf.c     ****                         s++;
 468              		.loc 1 125 0
 469 0020 631C     		adds	r3, r4, #1
 470              	.LVL41:
 127:_printf.c     ****                         format[0] = '%';
 471              		.loc 1 127 0
 472 0022 0122     		movs	r2, #1
 473              	.LVL42:
 474              	.L72:
 475 0024 1E46     		mov	r6, r3
 476              	.LVL43:
 129:_printf.c     ****                                 if (*s=='c' || *s=='d' || *s=='x' || *s=='s' || *s=='%'){
 477              		.loc 1 129 0
 478 0026 13F8010B 		ldrb	r0, [r3], #1	@ zero_extendqisi2
 479 002a A0F16301 		sub	r1, r0, #99
 480 002e C9B2     		uxtb	r1, r1
 481 0030 0129     		cmp	r1, #1
 135:_printf.c     ****                                         format[i++] = *s++;
 482              		.loc 1 135 0
 483 0032 1C46     		mov	r4, r3
 484              	.LVL44:
 129:_printf.c     ****                                 if (*s=='c' || *s=='d' || *s=='x' || *s=='s' || *s=='%'){
 485              		.loc 1 129 0
 486 0034 40F29C80 		bls	.L68
 129:_printf.c     ****                                 if (*s=='c' || *s=='d' || *s=='x' || *s=='s' || *s=='%'){
 487              		.loc 1 129 0 is_stmt 0 discriminator 1
 488 0038 7828     		cmp	r0, #120
 489 003a 00F09980 		beq	.L68
 490 003e 7328     		cmp	r0, #115
 491 0040 00F09680 		beq	.L68
 492 0044 2528     		cmp	r0, #37
 493 0046 00F09380 		beq	.L68
 135:_printf.c     ****                                         format[i++] = *s++;
 494              		.loc 1 135 0 is_stmt 1
 495 004a 02F11001 		add	r1, r2, #16
 496 004e 0132     		adds	r2, r2, #1
 497              	.LVL45:
 498 0050 EC46     		mov	ip, sp
 128:_printf.c     ****                         for (i=1; i<10;){
 499              		.loc 1 128 0
 500 0052 0A2A     		cmp	r2, #10
 135:_printf.c     ****                                         format[i++] = *s++;
 501              		.loc 1 135 0
 502 0054 01F80C00 		strb	r0, [r1, ip]
 503              	.LVL46:
 128:_printf.c     ****                         for (i=1; i<10;){
 504              		.loc 1 128 0
 505 0058 E4D1     		bne	.L72
 506 005a 7078     		ldrb	r0, [r6, #1]	@ zero_extendqisi2
 139:_printf.c     ****                         switch (*s++){
 507              		.loc 1 139 0
 508 005c 0134     		adds	r4, r4, #1
 509              	.LVL47:
 510 005e 6428     		cmp	r0, #100
 511 0060 00F09380 		beq	.L74
 512              	.LVL48:
 513              	.L217:
 514 0064 15D8     		bhi	.L75
 515 0066 2528     		cmp	r0, #37
 516 0068 00F01B81 		beq	.L76
 517 006c 6328     		cmp	r0, #99
 518 006e D1D1     		bne	.L66
 519              	.LBB57:
 520              	.LBB58:
 168:_printf.c     ****         print_byte(c);
 521              		.loc 1 168 0
 522 0070 9AF80000 		ldrb	r0, [r10]	@ zero_extendqisi2
 523 0074 A847     		blx	r5
 524              	.LVL49:
 525              	.LBE58:
 526              	.LBE57:
 123:_printf.c     ****         while (*s){
 527              		.loc 1 123 0
 528 0076 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 141:_printf.c     ****                                         PrintChar(format, va_arg(args, int));
 529              		.loc 1 141 0
 530 0078 0AF10406 		add	r6, r10, #4
 531              	.LVL50:
 532 007c B246     		mov	r10, r6
 123:_printf.c     ****         while (*s){
 533              		.loc 1 123 0
 534 007e 0028     		cmp	r0, #0
 535 0080 CAD1     		bne	.L152
 536              	.LVL51:
 537              	.L216:
 164:_printf.c     **** }
 538              		.loc 1 164 0
 539 0082 0BB0     		add	sp, sp, #44
 540              		@ sp needed
 541 0084 BDE8F04F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 542              	.LVL52:
 543 0088 04B0     		add	sp, sp, #16
 544 008a 7047     		bx	lr
 545              	.LVL53:
 546              	.L67:
 547              	.LBB59:
 548              	.LBB38:
 168:_printf.c     ****         print_byte(c);
 549              		.loc 1 168 0
 550 008c A847     		blx	r5
 551              	.LVL54:
 552              	.LBE38:
 553              	.LBE59:
 159:_printf.c     ****                         s++;
 554              		.loc 1 159 0
 555 008e 0134     		adds	r4, r4, #1
 556              	.LVL55:
 557 0090 C0E7     		b	.L66
 558              	.LVL56:
 559              	.L75:
 139:_printf.c     ****                         switch (*s++){
 560              		.loc 1 139 0
 561 0092 7328     		cmp	r0, #115
 562 0094 00F00781 		beq	.L78
 563 0098 7828     		cmp	r0, #120
 564 009a BBD1     		bne	.L66
 147:_printf.c     ****                                         PrintHex(format, va_arg(args, int));
 565              		.loc 1 147 0
 566 009c DAF80090 		ldr	r9, [r10]
 567              	.LBB60:
 568              	.LBB61:
 192:_printf.c     ****                 }
 193:_printf.c     ****                 else if (c=='0') flag0=true;
 194:_printf.c     ****                 else if (c=='l') flagl=true;
 195:_printf.c     ****                 else continue;
 196:_printf.c     ****         }
 197:_printf.c     **** 
 198:_printf.c     **** 
 199:_printf.c     ****         // 위의 flag에 따라 출력.
 200:_printf.c     ****         if (flagcnt){
 201:_printf.c     ****                 if (flagcnt>9) flagcnt=9;
 202:_printf.c     ****                 remainder = l%(Power(10, flagcnt));        // flagcnt보다 윗자리의 수는 걸러냄. 199
 203:_printf.c     **** 
 204:_printf.c     **** 
 205:_printf.c     ****                 for (divisor=Power(10, flagcnt-1); divisor>0; divisor/=10){
 206:_printf.c     ****                         result = remainder/divisor;
 207:_printf.c     ****                         remainder %= divisor;
 208:_printf.c     **** 
 209:_printf.c     **** 
 210:_printf.c     ****                         if (result!=0 || divisor==1) leading_zero = false;
 211:_printf.c     **** 
 212:_printf.c     **** 
 213:_printf.c     ****                         if (leading_zero==true){
 214:_printf.c     ****                                 if (flag0)        print_byte('0');
 215:_printf.c     ****                                 else                print_byte(' ');
 216:_printf.c     ****                         }
 217:_printf.c     ****                         else print_byte((char)(result)+'0');
 218:_printf.c     ****                 }
 219:_printf.c     ****         } else {
 220:_printf.c     ****                 remainder = l;
 221:_printf.c     **** 
 222:_printf.c     **** 
 223:_printf.c     ****                 for (divisor=1000000000; divisor>0; divisor/=10){
 224:_printf.c     ****                         result = remainder/divisor;
 225:_printf.c     ****                         remainder %= divisor;
 226:_printf.c     **** 
 227:_printf.c     **** 
 228:_printf.c     ****                         if (result!=0 || divisor==1) leading_zero = false;
 229:_printf.c     ****                         if (leading_zero==false) print_byte((char)(result)+'0');
 230:_printf.c     ****                 }
 231:_printf.c     ****         }
 232:_printf.c     ****         return;
 233:_printf.c     **** }
 234:_printf.c     **** 
 235:_printf.c     **** void PrintHex(char *fmt, int l){
 236:_printf.c     ****         int                i, j;
 237:_printf.c     ****         char        c, *s=fmt, tol[10];
 238:_printf.c     ****         bool        flag0=false, flagl=false;        // flags.
 239:_printf.c     ****         long        flagcnt=0;
 240:_printf.c     ****         bool        leading_zero=true;
 241:_printf.c     ****         char        uHex, lHex;
 242:_printf.c     ****         int                cnt;                                                // "%5x"의 경우 5개
 243:_printf.c     **** 
 244:_printf.c     **** 
 245:_printf.c     ****         // fmt의 "%08lx"에서 '0', '8', 'l'을 해석.
 246:_printf.c     ****         for (i=0; (c=s[i]) != 0; i++){
 569              		.loc 1 246 0
 570 00a0 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 239:_printf.c     ****         long        flagcnt=0;
 571              		.loc 1 239 0
 572 00a4 0026     		movs	r6, #0
 573              	.LBE61:
 574              	.LBE60:
 147:_printf.c     ****                                         PrintHex(format, va_arg(args, int));
 575              		.loc 1 147 0
 576 00a6 0AF1040A 		add	r10, r10, #4
 577              	.LVL57:
 578 00aa CDF80890 		str	r9, [sp, #8]
 579 00ae CDF804A0 		str	r10, [sp, #4]
 580              	.LVL58:
 581              	.LBB67:
 582              	.LBB62:
 239:_printf.c     ****         long        flagcnt=0;
 583              		.loc 1 239 0
 584 00b2 0396     		str	r6, [sp, #12]
 585              	.LVL59:
 586              		.loc 1 246 0
 587 00b4 002B     		cmp	r3, #0
 588 00b6 00F03381 		beq	.L107
 247:_printf.c     ****                 if (c=='x') break;
 589              		.loc 1 247 0
 590 00ba 782B     		cmp	r3, #120
 591 00bc 00F03081 		beq	.L107
 246:_printf.c     ****         for (i=0; (c=s[i]) != 0; i++){
 592              		.loc 1 246 0
 593 00c0 B346     		mov	fp, r6
 248:_printf.c     ****                 else if (c>='1' && c<='9'){
 249:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 250:_printf.c     ****                                 tol[j] = s[i++];
 251:_printf.c     ****                         }
 252:_printf.c     ****                         tol[j] = '\0';
 594              		.loc 1 252 0
 595 00c2 B046     		mov	r8, r6
 249:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 596              		.loc 1 249 0
 597 00c4 0DF1100A 		add	r10, sp, #16
 598              	.LVL60:
 599              	.L108:
 248:_printf.c     ****                 else if (c>='1' && c<='9'){
 600              		.loc 1 248 0
 601 00c8 A3F13102 		sub	r2, r3, #49
 602 00cc D2B2     		uxtb	r2, r2
 603 00ce 082A     		cmp	r2, #8
 604 00d0 4AD8     		bhi	.L111
 605              	.LVL61:
 249:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 606              		.loc 1 249 0
 607 00d2 1AF80B20 		ldrb	r2, [r10, fp]	@ zero_extendqisi2
 608 00d6 0AEB0B01 		add	r1, r10, fp
 609 00da A2F13003 		sub	r3, r2, #48
 610              	.LVL62:
 611 00de DBB2     		uxtb	r3, r3
 612 00e0 092B     		cmp	r3, #9
 613 00e2 07A8     		add	r0, sp, #28
 614 00e4 4FF00003 		mov	r3, #0
 615 00e8 0DD8     		bhi	.L112
 616              	.LVL63:
 617              	.L113:
 250:_printf.c     ****                                 tol[j] = s[i++];
 618              		.loc 1 250 0
 619 00ea C254     		strb	r2, [r0, r3]
 249:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 620              		.loc 1 249 0
 621 00ec 11F8012F 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 250:_printf.c     ****                                 tol[j] = s[i++];
 622              		.loc 1 250 0
 623 00f0 0BF1010B 		add	fp, fp, #1
 624              	.LVL64:
 249:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 625              		.loc 1 249 0
 626 00f4 A2F1300E 		sub	lr, r2, #48
 627 00f8 5FFA8EFE 		uxtb	lr, lr
 628 00fc BEF1090F 		cmp	lr, #9
 629 0100 03F10103 		add	r3, r3, #1
 630              	.LVL65:
 631 0104 F1D9     		bls	.L113
 632              	.LVL66:
 633              	.L112:
 634              		.loc 1 252 0
 635 0106 0AA9     		add	r1, sp, #40
 636 0108 0B44     		add	r3, r3, r1
 253:_printf.c     ****                         i--;
 254:_printf.c     ****                         DecToLong(tol, &flagcnt);
 637              		.loc 1 254 0
 638 010a 03A9     		add	r1, sp, #12
 252:_printf.c     ****                         tol[j] = '\0';
 639              		.loc 1 252 0
 640 010c 03F80C8C 		strb	r8, [r3, #-12]
 253:_printf.c     ****                         i--;
 641              		.loc 1 253 0
 642 0110 0BF1FF3B 		add	fp, fp, #-1
 643              	.LVL67:
 644              		.loc 1 254 0
 645 0114 B847     		blx	r7
 646              	.LVL68:
 647              	.L114:
 246:_printf.c     ****         for (i=0; (c=s[i]) != 0; i++){
 648              		.loc 1 246 0
 649 0116 0BF1010B 		add	fp, fp, #1
 650              	.LVL69:
 651 011a 0AAB     		add	r3, sp, #40
 652 011c 5B44     		add	r3, r3, fp
 653 011e 13F8183C 		ldrb	r3, [r3, #-24]	@ zero_extendqisi2
 654              	.LVL70:
 655 0122 0BB1     		cbz	r3, .L213
 247:_printf.c     ****                 if (c=='x') break;
 656              		.loc 1 247 0
 657 0124 782B     		cmp	r3, #120
 658 0126 CFD1     		bne	.L108
 659              	.L213:
 660              	.LVL71:
 661 0128 039B     		ldr	r3, [sp, #12]
 662 012a 99FA89F2 		rev	r2, r9
 255:_printf.c     ****                 }
 256:_printf.c     ****                 else if (c=='0') flag0=true;
 257:_printf.c     ****                 else if (c=='l') flagl=true;
 258:_printf.c     ****                 else continue;
 259:_printf.c     ****         }
 260:_printf.c     **** 
 261:_printf.c     ****         s = (char *)(&l);
 262:_printf.c     ****         l = SWAP32(l);                // little, big endian에 따라서.(big이 출력하기 쉬워 순서를 바
 663              		.loc 1 262 0
 664 012e 0292     		str	r2, [sp, #8]
 263:_printf.c     ****         
 264:_printf.c     ****         // 위의 flag에 따라 출력.
 265:_printf.c     ****         if (flagcnt){
 665              		.loc 1 265 0
 666 0130 002B     		cmp	r3, #0
 667 0132 00F0F880 		beq	.L116
 266:_printf.c     ****                 if (flagcnt&0x01){        // flagcnt가 홀수 일때, upper를 무시, lower만 출력.
 668              		.loc 1 266 0
 669 0136 DA07     		lsls	r2, r3, #31
 670 0138 40F12881 		bpl	.L160
 671              	.LVL72:
 267:_printf.c     ****                         c = s[(8-(flagcnt+1))/2]; // 홀수 일때 그 위치를 포함하는 곳의 값을 가져 옵
 672              		.loc 1 267 0
 673 013c C3F10703 		rsb	r3, r3, #7
 674              	.LVL73:
 675 0140 03EBD373 		add	r3, r3, r3, lsr #31
 676              	.LVL74:
 677 0144 0AAA     		add	r2, sp, #40
 678 0146 02EB6303 		add	r3, r2, r3, asr #1
 268:_printf.c     ****                         
 269:_printf.c     ****                         // lower 4 bits를 가져와서 ascii code로.
 270:_printf.c     ****                         lHex = ((c>>0)&0x0f);
 679              		.loc 1 270 0
 680 014a 13F8203C 		ldrb	r3, [r3, #-32]	@ zero_extendqisi2
 681              	.LVL75:
 271:_printf.c     ****                         if (lHex!=0) leading_zero=false;
 682              		.loc 1 271 0
 683 014e 13F00F03 		ands	r3, r3, #15
 684              	.LVL76:
 685 0152 00F06081 		beq	.L118
 686              	.LVL77:
 272:_printf.c     ****                         if (lHex<10) lHex+='0';
 687              		.loc 1 272 0
 688 0156 092B     		cmp	r3, #9
 689 0158 40F28081 		bls	.L119
 273:_printf.c     ****                         else         lHex+='A'-10;
 690              		.loc 1 273 0
 691 015c 03F13700 		add	r0, r3, #55
 692              	.LVL78:
 693              	.L120:
 274:_printf.c     **** 
 275:_printf.c     ****                         // lower 4 bits 출력.
 276:_printf.c     ****                         if (leading_zero){
 277:_printf.c     ****                                 if (flag0) print_byte('0');
 278:_printf.c     ****                                 else       print_byte(' ');
 279:_printf.c     ****                         }
 280:_printf.c     ****                         else print_byte(lHex);
 694              		.loc 1 280 0
 695 0160 A847     		blx	r5
 696              	.LVL79:
 697 0162 4FF00009 		mov	r9, #0
 698 0166 5BE1     		b	.L121
 699              	.LVL80:
 700              	.L111:
 256:_printf.c     ****                 else if (c=='0') flag0=true;
 701              		.loc 1 256 0
 702 0168 302B     		cmp	r3, #48
 703 016a 08BF     		it	eq
 704 016c 0126     		moveq	r6, #1
 705              	.LVL81:
 706 016e D2E7     		b	.L114
 707              	.LVL82:
 708              	.L68:
 709              	.LBE62:
 710              	.LBE67:
 130:_printf.c     ****                                         format[i++] = *s;
 711              		.loc 1 130 0
 712 0170 0AA9     		add	r1, sp, #40
 713 0172 0A44     		add	r2, r2, r1
 714              	.LVL83:
 131:_printf.c     ****                                         format[i] = '\0';
 715              		.loc 1 131 0
 716 0174 0023     		movs	r3, #0
 717              	.LVL84:
 132:_printf.c     ****                                         break;
 718              		.loc 1 132 0
 719 0176 3446     		mov	r4, r6
 720              	.LVL85:
 139:_printf.c     ****                         switch (*s++){
 721              		.loc 1 139 0
 722 0178 6428     		cmp	r0, #100
 130:_printf.c     ****                                         format[i++] = *s;
 723              		.loc 1 130 0
 724 017a 02F8180C 		strb	r0, [r2, #-24]
 131:_printf.c     ****                                         format[i] = '\0';
 725              		.loc 1 131 0
 726 017e 02F8173C 		strb	r3, [r2, #-23]
 139:_printf.c     ****                         switch (*s++){
 727              		.loc 1 139 0
 728 0182 04F10104 		add	r4, r4, #1
 729              	.LVL86:
 730 0186 7FF46DAF 		bne	.L217
 731              	.L74:
 732              	.LBB68:
 733              	.LBB51:
 183:_printf.c     ****         for (i=0; (c=s[i]) != 0; i++){
 734              		.loc 1 183 0
 735 018a 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 177:_printf.c     ****         long        flagcnt=0;                                        // "%08lx"에서 "8"을 찾아서 l
 736              		.loc 1 177 0
 737 018e 0026     		movs	r6, #0
 738              	.LBE51:
 739              	.LBE68:
 144:_printf.c     ****                                         PrintDec(format, va_arg(args, int));
 740              		.loc 1 144 0
 741 0190 0AF10402 		add	r2, r10, #4
 742              	.LBB69:
 743              	.LBB52:
 177:_printf.c     ****         long        flagcnt=0;                                        // "%08lx"에서 "8"을 찾아서 l
 744              		.loc 1 177 0
 745 0194 0396     		str	r6, [sp, #12]
 746              	.LBE52:
 747              	.LBE69:
 144:_printf.c     ****                                         PrintDec(format, va_arg(args, int));
 748              		.loc 1 144 0
 749 0196 0192     		str	r2, [sp, #4]
 750              	.LVL87:
 751 0198 DAF800B0 		ldr	fp, [r10]
 752              	.LVL88:
 753              	.LBB70:
 754              	.LBB53:
 183:_printf.c     ****         for (i=0; (c=s[i]) != 0; i++){
 755              		.loc 1 183 0
 756 019c 002B     		cmp	r3, #0
 757 019e 00F09780 		beq	.L80
 184:_printf.c     ****                 if (c=='d') break;
 758              		.loc 1 184 0
 759 01a2 642B     		cmp	r3, #100
 760 01a4 00F09480 		beq	.L80
 183:_printf.c     ****         for (i=0; (c=s[i]) != 0; i++){
 761              		.loc 1 183 0
 762 01a8 B246     		mov	r10, r6
 189:_printf.c     ****                         tol[j] = '\0';
 763              		.loc 1 189 0
 764 01aa B046     		mov	r8, r6
 186:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 765              		.loc 1 186 0
 766 01ac 0DF11009 		add	r9, sp, #16
 767              	.LVL89:
 768              	.L81:
 185:_printf.c     ****                 else if (c>='1' && c<='9'){
 769              		.loc 1 185 0
 770 01b0 A3F13102 		sub	r2, r3, #49
 771 01b4 D2B2     		uxtb	r2, r2
 772 01b6 082A     		cmp	r2, #8
 773 01b8 00F28680 		bhi	.L84
 774              	.LVL90:
 186:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 775              		.loc 1 186 0
 776 01bc 19F80A20 		ldrb	r2, [r9, r10]	@ zero_extendqisi2
 777 01c0 09EB0A01 		add	r1, r9, r10
 778 01c4 A2F13003 		sub	r3, r2, #48
 779              	.LVL91:
 780 01c8 DBB2     		uxtb	r3, r3
 781 01ca 092B     		cmp	r3, #9
 782 01cc 07A8     		add	r0, sp, #28
 783 01ce 4FF00003 		mov	r3, #0
 784 01d2 0DD8     		bhi	.L85
 785              	.LVL92:
 786              	.L86:
 187:_printf.c     ****                                 tol[j] = s[i++];
 787              		.loc 1 187 0
 788 01d4 C254     		strb	r2, [r0, r3]
 186:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 789              		.loc 1 186 0
 790 01d6 11F8012F 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 187:_printf.c     ****                                 tol[j] = s[i++];
 791              		.loc 1 187 0
 792 01da 0AF1010A 		add	r10, r10, #1
 793              	.LVL93:
 186:_printf.c     ****                         for (j=0; s[i]>='0' && s[i]<='9'; j++){
 794              		.loc 1 186 0
 795 01de A2F1300E 		sub	lr, r2, #48
 796 01e2 5FFA8EFE 		uxtb	lr, lr
 797 01e6 BEF1090F 		cmp	lr, #9
 798 01ea 03F10103 		add	r3, r3, #1
 799              	.LVL94:
 800 01ee F1D9     		bls	.L86
 801              	.LVL95:
 802              	.L85:
 189:_printf.c     ****                         tol[j] = '\0';
 803              		.loc 1 189 0
 804 01f0 0DF1280C 		add	ip, sp, #40
 805 01f4 6344     		add	r3, r3, ip
 191:_printf.c     ****                         DecToLong(tol, &flagcnt);
 806              		.loc 1 191 0
 807 01f6 03A9     		add	r1, sp, #12
 189:_printf.c     ****                         tol[j] = '\0';
 808              		.loc 1 189 0
 809 01f8 03F80C8C 		strb	r8, [r3, #-12]
 190:_printf.c     ****                         i--;
 810              		.loc 1 190 0
 811 01fc 0AF1FF3A 		add	r10, r10, #-1
 812              	.LVL96:
 191:_printf.c     ****                         DecToLong(tol, &flagcnt);
 813              		.loc 1 191 0
 814 0200 B847     		blx	r7
 815              	.LVL97:
 816              	.L87:
 183:_printf.c     ****         for (i=0; (c=s[i]) != 0; i++){
 817              		.loc 1 183 0
 818 0202 0AF1010A 		add	r10, r10, #1
 819              	.LVL98:
 820 0206 0AAB     		add	r3, sp, #40
 821 0208 5344     		add	r3, r3, r10
 822 020a 13F8183C 		ldrb	r3, [r3, #-24]	@ zero_extendqisi2
 823              	.LVL99:
 824 020e 0BB1     		cbz	r3, .L89
 184:_printf.c     ****                 if (c=='d') break;
 825              		.loc 1 184 0
 826 0210 642B     		cmp	r3, #100
 827 0212 CDD1     		bne	.L81
 828              	.L89:
 200:_printf.c     ****         if (flagcnt){
 829              		.loc 1 200 0
 830 0214 0399     		ldr	r1, [sp, #12]
 831 0216 0029     		cmp	r1, #0
 832 0218 5AD0     		beq	.L80
 201:_printf.c     ****                 if (flagcnt>9) flagcnt=9;
 833              		.loc 1 201 0
 834 021a 0929     		cmp	r1, #9
 835 021c 40F3B080 		ble	.L90
 836 0220 0921     		movs	r1, #9
 837 0222 0391     		str	r1, [sp, #12]
 838              	.LVL100:
 839 0224 0620     		movs	r0, #6
 840              	.LBB41:
 841              	.LBB42:
 281:_printf.c     ****                         
 282:_printf.c     ****                         flagcnt--;
 283:_printf.c     ****                 }
 284:_printf.c     **** 
 285:_printf.c     ****                 // byte단위의 data를 Hex로 출력.
 286:_printf.c     ****                 for (cnt=0, i=(8-flagcnt)/2; i<4; i++){
 287:_printf.c     ****                         c = s[i];
 288:_printf.c     ****                                 
 289:_printf.c     ****                         // get upper 4 bits and lower 4 bits.
 290:_printf.c     ****                         uHex = ((c>>4)&0x0f);
 291:_printf.c     ****                         lHex = ((c>>0)&0x0f);
 292:_printf.c     **** 
 293:_printf.c     ****                         // upper 4 bits and lower 4 bits to '0'~'9', 'A'~'F'.
 294:_printf.c     ****                         // upper 4 bits를 ascii code로.
 295:_printf.c     ****                         if (uHex!=0) leading_zero = false;
 296:_printf.c     ****                         if (uHex<10) uHex+='0';
 297:_printf.c     ****                         else         uHex+='A'-10;
 298:_printf.c     **** 
 299:_printf.c     ****                         // upper 4 bits 출력.
 300:_printf.c     ****                         if (leading_zero){
 301:_printf.c     ****                                 if (flag0) print_byte('0');
 302:_printf.c     ****                                 else       print_byte(' ');
 303:_printf.c     ****                         }
 304:_printf.c     ****                         else print_byte(uHex);
 305:_printf.c     ****                         
 306:_printf.c     ****                         // lower 4 bits를 ascii code로.
 307:_printf.c     ****                         if (lHex!=0) leading_zero = false;
 308:_printf.c     ****                         if (lHex<10) lHex+='0';
 309:_printf.c     ****                         else         lHex+='A'-10;
 310:_printf.c     **** 
 311:_printf.c     ****                         // lower 4 bits 출력.
 312:_printf.c     ****                         if (leading_zero){
 313:_printf.c     ****                                 if (flag0) print_byte('0');
 314:_printf.c     ****                                 else       print_byte(' ');
 315:_printf.c     ****                         }
 316:_printf.c     ****                         else print_byte(lHex);
 317:_printf.c     ****                 }
 318:_printf.c     ****         }
 319:_printf.c     ****         else {
 320:_printf.c     ****                 for (i=0; i<4; i++){
 321:_printf.c     ****                         c = s[i];
 322:_printf.c     ****         
 323:_printf.c     ****                         // get upper 4 bits and lower 4 bits.
 324:_printf.c     ****                         uHex = ((c>>4)&0x0f);
 325:_printf.c     ****                         lHex = ((c>>0)&0x0f);
 326:_printf.c     **** 
 327:_printf.c     **** 
 328:_printf.c     ****                         // upper 4 bits and lower 4 bits to '0'~'9', 'A'~'F'.
 329:_printf.c     ****                         if (uHex!=0) leading_zero = false;
 330:_printf.c     ****                         if (uHex<10) uHex+='0';
 331:_printf.c     ****                         else         uHex+='A'-10;
 332:_printf.c     ****                         if (!leading_zero) print_byte(uHex);
 333:_printf.c     ****                         
 334:_printf.c     ****                         if (lHex!=0 || i==3) leading_zero = false;
 335:_printf.c     ****                         if (lHex<10) lHex+='0';
 336:_printf.c     ****                         else         lHex+='A'-10;
 337:_printf.c     ****                         if (!leading_zero) print_byte(lHex);
 338:_printf.c     ****                 }
 339:_printf.c     ****         }
 340:_printf.c     ****         return;
 341:_printf.c     **** }
 342:_printf.c     **** 
 343:_printf.c     **** void PrintString(char *fmt, char *s){
 344:_printf.c     ****         if (!fmt || !s) return;
 345:_printf.c     ****         while (*s) print_byte(*s++);
 346:_printf.c     ****         return;
 347:_printf.c     **** }
 348:_printf.c     **** 
 349:_printf.c     **** int Power(int num, int cnt){
 350:_printf.c     ****         long retval=num;
 351:_printf.c     ****         cnt--;
 352:_printf.c     **** 
 353:_printf.c     **** 
 354:_printf.c     ****         while (cnt--){
 842              		.loc 1 354 0
 843 0226 0722     		movs	r2, #7
 844              	.LVL101:
 845              	.L94:
 846 0228 0A23     		movs	r3, #10
 847              	.LVL102:
 848              	.L91:
 849 022a 013A     		subs	r2, r2, #1
 850              	.LVL103:
 355:_printf.c     ****                 retval *= num;
 851              		.loc 1 355 0
 852 022c 03EB8303 		add	r3, r3, r3, lsl #2
 853              	.LVL104:
 354:_printf.c     ****         while (cnt--){
 854              		.loc 1 354 0
 855 0230 B2F1FF3F 		cmp	r2, #-1
 856              		.loc 1 355 0
 857 0234 4FEA4303 		lsl	r3, r3, #1
 858              	.LVL105:
 354:_printf.c     ****         while (cnt--){
 859              		.loc 1 354 0
 860 0238 F7D1     		bne	.L91
 861              	.LBE42:
 862              	.LBE41:
 202:_printf.c     ****                 remainder = l%(Power(10, flagcnt));        // flagcnt보다 윗자리의 수는 걸러냄. 199
 863              		.loc 1 202 0
 864 023a 9BFBF3FA 		sdiv	r10, fp, r3
 865              	.LVL106:
 866              	.LBB44:
 867              	.LBB45:
 354:_printf.c     ****         while (cnt--){
 868              		.loc 1 354 0
 869 023e 0229     		cmp	r1, #2
 870              	.LBE45:
 871              	.LBE44:
 202:_printf.c     ****                 remainder = l%(Power(10, flagcnt));        // flagcnt보다 윗자리의 수는 걸러냄. 199
 872              		.loc 1 202 0
 873 0240 03FB1ABA 		mls	r10, r3, r10, fp
 874              	.LVL107:
 875              	.LBB48:
 876              	.LBB46:
 354:_printf.c     ****         while (cnt--){
 877              		.loc 1 354 0
 878 0244 00F00481 		beq	.L157
 879 0248 0346     		mov	r3, r0
 880              	.LVL108:
 881              	.L93:
 350:_printf.c     ****         long retval=num;
 882              		.loc 1 350 0
 883 024a 4FF00A08 		mov	r8, #10
 884              	.LVL109:
 885              	.L97:
 354:_printf.c     ****         while (cnt--){
 886              		.loc 1 354 0
 887 024e 013B     		subs	r3, r3, #1
 888              	.LVL110:
 889              		.loc 1 355 0
 890 0250 08EB8808 		add	r8, r8, r8, lsl #2
 891              	.LVL111:
 354:_printf.c     ****         while (cnt--){
 892              		.loc 1 354 0
 893 0254 591C     		adds	r1, r3, #1
 894              		.loc 1 355 0
 895 0256 4FEA4808 		lsl	r8, r8, #1
 896              	.LVL112:
 354:_printf.c     ****         while (cnt--){
 897              		.loc 1 354 0
 898 025a F8D1     		bne	.L97
 899              	.LVL113:
 900              	.L96:
 350:_printf.c     ****         long retval=num;
 901              		.loc 1 350 0
 902 025c 4FF0010B 		mov	fp, #1
 903              	.LVL114:
 904 0260 13E0     		b	.L102
 905              	.LVL115:
 906              	.L218:
 907              	.LBE46:
 908              	.LBE48:
 210:_printf.c     ****                         if (result!=0 || divisor==1) leading_zero = false;
 909              		.loc 1 210 0
 910 0262 B8F1010F 		cmp	r8, #1
 911 0266 18D0     		beq	.L98
 213:_printf.c     ****                         if (leading_zero==true){
 912              		.loc 1 213 0
 913 0268 BBF1000F 		cmp	fp, #0
 914 026c 15D0     		beq	.L98
 214:_printf.c     ****                                 if (flag0)        print_byte('0');
 915              		.loc 1 214 0
 916 026e 3020     		movs	r0, #48
 917 0270 06B9     		cbnz	r6, .L212
 215:_printf.c     ****                                 else                print_byte(' ');
 918              		.loc 1 215 0
 919 0272 2020     		movs	r0, #32
 920              	.L212:
 921 0274 A847     		blx	r5
 922              	.LVL116:
 923              	.L100:
 205:_printf.c     ****                 for (divisor=Power(10, flagcnt-1); divisor>0; divisor/=10){
 924              		.loc 1 205 0
 925 0276 284A     		ldr	r2, .L223+8
 926 0278 82FB0823 		smull	r2, r3, r2, r8
 927 027c 4FEAE878 		asr	r8, r8, #31
 928              	.LVL117:
 929 0280 C8EBA308 		rsb	r8, r8, r3, asr #2
 930              	.LVL118:
 931 0284 B8F1000F 		cmp	r8, #0
 932 0288 6BDD     		ble	.L137
 933              	.LVL119:
 934              	.L102:
 206:_printf.c     ****                         result = remainder/divisor;
 935              		.loc 1 206 0
 936 028a 9AFBF8F3 		sdiv	r3, r10, r8
 937              	.LVL120:
 217:_printf.c     ****                         else print_byte((char)(result)+'0');
 938              		.loc 1 217 0
 939 028e D8B2     		uxtb	r0, r3
 940 0290 3030     		adds	r0, r0, #48
 207:_printf.c     ****                         remainder %= divisor;
 941              		.loc 1 207 0
 942 0292 08FB13AA 		mls	r10, r8, r3, r10
 943              	.LVL121:
 210:_printf.c     ****                         if (result!=0 || divisor==1) leading_zero = false;
 944              		.loc 1 210 0
 945 0296 002B     		cmp	r3, #0
 946 0298 E3D0     		beq	.L218
 947              	.LVL122:
 948              	.L98:
 217:_printf.c     ****                         else print_byte((char)(result)+'0');
 949              		.loc 1 217 0
 950 029a A847     		blx	r5
 951              	.LVL123:
 952 029c 4FF0000B 		mov	fp, #0
 953 02a0 E9E7     		b	.L100
 954              	.LVL124:
 955              	.L76:
 956              	.LBE53:
 957              	.LBE70:
 958              	.LBB71:
 959              	.LBB72:
 168:_printf.c     ****         print_byte(c);
 960              		.loc 1 168 0
 961 02a2 A847     		blx	r5
 962              	.LVL125:
 963 02a4 B6E6     		b	.L66
 964              	.LVL126:
 965              	.L78:
 966              	.LBE72:
 967              	.LBE71:
 150:_printf.c     ****                                         PrintString(format, va_arg(args, char *));
 968              		.loc 1 150 0
 969 02a6 DAF80060 		ldr	r6, [r10]
 970 02aa 0AF1040A 		add	r10, r10, #4
 971              	.LVL127:
 972              	.LBB73:
 973              	.LBB74:
 344:_printf.c     ****         if (!fmt || !s) return;
 974              		.loc 1 344 0
 975 02ae 002E     		cmp	r6, #0
 976 02b0 3FF4B0AE 		beq	.L66
 345:_printf.c     ****         while (*s) print_byte(*s++);
 977              		.loc 1 345 0
 978 02b4 3078     		ldrb	r0, [r6]	@ zero_extendqisi2
 979 02b6 0028     		cmp	r0, #0
 980 02b8 3FF4ACAE 		beq	.L66
 981              	.LVL128:
 982              	.L151:
 983 02bc A847     		blx	r5
 984              	.LVL129:
 985 02be 16F8010F 		ldrb	r0, [r6, #1]!	@ zero_extendqisi2
 986              	.LVL130:
 987 02c2 0028     		cmp	r0, #0
 988 02c4 FAD1     		bne	.L151
 989 02c6 A5E6     		b	.L66
 990              	.LVL131:
 991              	.L84:
 992              	.LBE74:
 993              	.LBE73:
 994              	.LBB75:
 995              	.LBB54:
 193:_printf.c     ****                 else if (c=='0') flag0=true;
 996              		.loc 1 193 0
 997 02c8 302B     		cmp	r3, #48
 998 02ca 08BF     		it	eq
 999 02cc 0126     		moveq	r6, #1
 1000              	.LVL132:
 1001 02ce 98E7     		b	.L87
 1002              	.LVL133:
 1003              	.L80:
 217:_printf.c     ****                         else print_byte((char)(result)+'0');
 1004              		.loc 1 217 0
 1005 02d0 4FF00A08 		mov	r8, #10
 1006 02d4 0122     		movs	r2, #1
 1007 02d6 114E     		ldr	r6, .L223+12
 1008 02d8 0CE0     		b	.L153
 1009              	.LVL134:
 1010              	.L103:
 229:_printf.c     ****                         if (leading_zero==false) print_byte((char)(result)+'0');
 1011              		.loc 1 229 0
 1012 02da A847     		blx	r5
 1013              	.LVL135:
 1014 02dc 0022     		movs	r2, #0
 1015              	.L104:
 223:_printf.c     ****                 for (divisor=1000000000; divisor>0; divisor/=10){
 1016              		.loc 1 223 0
 1017 02de DFF838C0 		ldr	ip, .L223+8
 1018 02e2 B8F10108 		subs	r8, r8, #1
 1019 02e6 8CFB06C3 		smull	ip, r3, ip, r6
 1020 02ea 4FEAE676 		asr	r6, r6, #31
 1021              	.LVL136:
 1022 02ee C6EBA306 		rsb	r6, r6, r3, asr #2
 1023              	.LVL137:
 1024 02f2 36D0     		beq	.L137
 1025              	.LVL138:
 1026              	.L153:
 224:_printf.c     ****                         result = remainder/divisor;
 1027              		.loc 1 224 0
 1028 02f4 9BFBF6F3 		sdiv	r3, fp, r6
 1029              	.LVL139:
 229:_printf.c     ****                         if (leading_zero==false) print_byte((char)(result)+'0');
 1030              		.loc 1 229 0
 1031 02f8 D8B2     		uxtb	r0, r3
 1032 02fa 3030     		adds	r0, r0, #48
 225:_printf.c     ****                         remainder %= divisor;
 1033              		.loc 1 225 0
 1034 02fc 06FB13BB 		mls	fp, r6, r3, fp
 1035              	.LVL140:
 228:_printf.c     ****                         if (result!=0 || divisor==1) leading_zero = false;
 1036              		.loc 1 228 0
 1037 0300 002B     		cmp	r3, #0
 1038 0302 EAD1     		bne	.L103
 1039              	.LVL141:
 1040 0304 012E     		cmp	r6, #1
 1041 0306 E8D0     		beq	.L103
 229:_printf.c     ****                         if (leading_zero==false) print_byte((char)(result)+'0');
 1042              		.loc 1 229 0
 1043 0308 002A     		cmp	r2, #0
 1044 030a E6D0     		beq	.L103
 1045 030c 0122     		movs	r2, #1
 1046              	.LVL142:
 1047 030e E6E7     		b	.L104
 1048              	.L224:
 1049              		.align	2
 1050              	.L223:
 1051 0310 00000000 		.word	print_byte
 1052 0314 00000000 		.word	DecToLong
 1053 0318 67666666 		.word	1717986919
 1054 031c 00CA9A3B 		.word	1000000000
 1055              	.LVL143:
 1056              	.L107:
 1057 0320 99FA89F3 		rev	r3, r9
 1058              	.LBE54:
 1059              	.LBE75:
 1060              	.LBB76:
 1061              	.LBB63:
 262:_printf.c     ****         l = SWAP32(l);                // little, big endian에 따라서.(big이 출력하기 쉬워 순서를 바
 1062              		.loc 1 262 0
 1063 0324 0293     		str	r3, [sp, #8]
 1064              	.LVL144:
 1065              	.L116:
 316:_printf.c     ****                         else print_byte(lHex);
 1066              		.loc 1 316 0
 1067 0326 0122     		movs	r2, #1
 1068 0328 0026     		movs	r6, #0
 1069 032a 0DF10808 		add	r8, sp, #8
 1070              	.LVL145:
 1071 032e A146     		mov	r9, r4
 1072              	.LVL146:
 1073              	.L150:
 321:_printf.c     ****                         c = s[i];
 1074              		.loc 1 321 0
 1075 0330 18F80630 		ldrb	r3, [r8, r6]	@ zero_extendqisi2
 1076              	.LVL147:
 325:_printf.c     ****                         lHex = ((c>>0)&0x0f);
 1077              		.loc 1 325 0
 1078 0334 03F00F04 		and	r4, r3, #15
 1079              	.LVL148:
 329:_printf.c     ****                         if (uHex!=0) leading_zero = false;
 1080              		.loc 1 329 0
 1081 0338 1B09     		lsrs	r3, r3, #4
 1082              	.LVL149:
 1083 033a 1DD0     		beq	.L139
 1084              	.LVL150:
 330:_printf.c     ****                         if (uHex<10) uHex+='0';
 1085              		.loc 1 330 0
 1086 033c 092B     		cmp	r3, #9
 331:_printf.c     ****                         else         uHex+='A'-10;
 1087              		.loc 1 331 0
 1088 033e 88BF     		it	hi
 1089 0340 03F13700 		addhi	r0, r3, #55
 330:_printf.c     ****                         if (uHex<10) uHex+='0';
 1090              		.loc 1 330 0
 1091 0344 40F29380 		bls	.L140
 1092              	.LVL151:
 1093              	.L143:
 332:_printf.c     ****                         if (!leading_zero) print_byte(uHex);
 1094              		.loc 1 332 0
 1095 0348 A847     		blx	r5
 1096              	.LVL152:
 1097 034a 0023     		movs	r3, #0
 1098              	.L142:
 334:_printf.c     ****                         if (lHex!=0 || i==3) leading_zero = false;
 1099              		.loc 1 334 0
 1100 034c 64B9     		cbnz	r4, .L144
 1101 034e 032E     		cmp	r6, #3
 1102 0350 00F08180 		beq	.L145
 1103              	.LVL153:
 337:_printf.c     ****                         if (!leading_zero) print_byte(lHex);
 1104              		.loc 1 337 0
 1105 0354 0122     		movs	r2, #1
 1106 0356 002B     		cmp	r3, #0
 1107 0358 7DD0     		beq	.L145
 1108              	.LVL154:
 1109              	.L148:
 320:_printf.c     ****                 for (i=0; i<4; i++){
 1110              		.loc 1 320 0
 1111 035a 0136     		adds	r6, r6, #1
 1112              	.LVL155:
 1113 035c 042E     		cmp	r6, #4
 1114 035e E7D1     		bne	.L150
 1115              	.LVL156:
 1116              	.L214:
 1117 0360 4C46     		mov	r4, r9
 1118              	.LVL157:
 1119              	.L137:
 1120              	.LBE63:
 1121              	.LBE76:
 147:_printf.c     ****                                         PrintHex(format, va_arg(args, int));
 1122              		.loc 1 147 0
 1123 0362 DDF804A0 		ldr	r10, [sp, #4]
 1124 0366 55E6     		b	.L66
 1125              	.LVL158:
 1126              	.L144:
 1127              	.LBB77:
 1128              	.LBB64:
 335:_printf.c     ****                         if (lHex<10) lHex+='0';
 1129              		.loc 1 335 0
 1130 0368 092C     		cmp	r4, #9
 336:_printf.c     ****                         else         lHex+='A'-10;
 1131              		.loc 1 336 0
 1132 036a 88BF     		it	hi
 1133 036c 04F13700 		addhi	r0, r4, #55
 335:_printf.c     ****                         if (lHex<10) lHex+='0';
 1134              		.loc 1 335 0
 1135 0370 71D9     		bls	.L145
 1136              	.LVL159:
 1137              	.L149:
 337:_printf.c     ****                         if (!leading_zero) print_byte(lHex);
 1138              		.loc 1 337 0
 1139 0372 A847     		blx	r5
 1140              	.LVL160:
 1141 0374 0022     		movs	r2, #0
 1142 0376 F0E7     		b	.L148
 1143              	.LVL161:
 1144              	.L139:
 332:_printf.c     ****                         if (!leading_zero) print_byte(uHex);
 1145              		.loc 1 332 0
 1146 0378 002A     		cmp	r2, #0
 1147 037a 78D0     		beq	.L140
 1148 037c 0123     		movs	r3, #1
 1149 037e E5E7     		b	.L142
 1150              	.LVL162:
 1151              	.L90:
 1152              	.LBE64:
 1153              	.LBE77:
 1154              	.LBB78:
 1155              	.LBB55:
 1156              	.LBB49:
 1157              	.LBB43:
 354:_printf.c     ****         while (cnt--){
 1158              		.loc 1 354 0
 1159 0380 0129     		cmp	r1, #1
 1160 0382 A1F10202 		sub	r2, r1, #2
 1161              	.LVL163:
 1162 0386 54D0     		beq	.L219
 1163 0388 C81E     		subs	r0, r1, #3
 1164 038a 4DE7     		b	.L94
 1165              	.LVL164:
 1166              	.L160:
 1167              	.LBE43:
 1168              	.LBE49:
 1169              	.LBE55:
 1170              	.LBE78:
 1171              	.LBB79:
 1172              	.LBB65:
 240:_printf.c     ****         bool        leading_zero=true;
 1173              		.loc 1 240 0
 1174 038c 4FF00109 		mov	r9, #1
 1175              	.LVL165:
 1176              	.L117:
 286:_printf.c     ****                 for (cnt=0, i=(8-flagcnt)/2; i<4; i++){
 1177              		.loc 1 286 0
 1178 0390 C3F10803 		rsb	r3, r3, #8
 1179 0394 03EBD373 		add	r3, r3, r3, lsr #31
 1180 0398 5B10     		asrs	r3, r3, #1
 1181              	.LVL166:
 1182 039a 032B     		cmp	r3, #3
 1183 039c E1DC     		bgt	.L137
 1184 039e 0DF10808 		add	r8, sp, #8
 1185              	.LVL167:
 1186 03a2 9844     		add	r8, r8, r3
 1187              	.LVL168:
 1188 03a4 3346     		mov	r3, r6
 1189              	.LVL169:
 1190 03a6 4E46     		mov	r6, r9
 1191              	.LVL170:
 1192 03a8 A146     		mov	r9, r4
 1193              	.LVL171:
 1194 03aa 1C46     		mov	r4, r3
 1195              	.LVL172:
 287:_printf.c     ****                         c = s[i];
 1196              		.loc 1 287 0
 1197 03ac 18F8013B 		ldrb	r3, [r8], #1	@ zero_extendqisi2
 1198              	.LVL173:
 1199 03b0 0DF10C0B 		add	fp, sp, #12
 291:_printf.c     ****                         lHex = ((c>>0)&0x0f);
 1200              		.loc 1 291 0
 1201 03b4 03F00F0A 		and	r10, r3, #15
 1202              	.LVL174:
 295:_printf.c     ****                         if (uHex!=0) leading_zero = false;
 1203              		.loc 1 295 0
 1204 03b8 1B09     		lsrs	r3, r3, #4
 1205              	.LVL175:
 1206 03ba 19D0     		beq	.L123
 1207              	.LVL176:
 1208              	.L220:
 296:_printf.c     ****                         if (uHex<10) uHex+='0';
 1209              		.loc 1 296 0
 1210 03bc 092B     		cmp	r3, #9
 297:_printf.c     ****                         else         uHex+='A'-10;
 1211              		.loc 1 297 0
 1212 03be 88BF     		it	hi
 1213 03c0 03F13700 		addhi	r0, r3, #55
 296:_printf.c     ****                         if (uHex<10) uHex+='0';
 1214              		.loc 1 296 0
 1215 03c4 50D9     		bls	.L124
 1216              	.LVL177:
 1217              	.L127:
 304:_printf.c     ****                         else print_byte(uHex);
 1218              		.loc 1 304 0
 1219 03c6 A847     		blx	r5
 1220              	.LVL178:
 1221 03c8 0026     		movs	r6, #0
 1222              	.L129:
 307:_printf.c     ****                         if (lHex!=0) leading_zero = false;
 1223              		.loc 1 307 0
 1224 03ca BAF1000F 		cmp	r10, #0
 1225 03ce 17D0     		beq	.L130
 1226              	.L221:
 1227              	.LVL179:
 308:_printf.c     ****                         if (lHex<10) lHex+='0';
 1228              		.loc 1 308 0
 1229 03d0 BAF1090F 		cmp	r10, #9
 309:_printf.c     ****                         else         lHex+='A'-10;
 1230              		.loc 1 309 0
 1231 03d4 88BF     		it	hi
 1232 03d6 0AF13700 		addhi	r0, r10, #55
 308:_printf.c     ****                         if (lHex<10) lHex+='0';
 1233              		.loc 1 308 0
 1234 03da 42D9     		bls	.L131
 1235              	.LVL180:
 1236              	.L134:
 316:_printf.c     ****                         else print_byte(lHex);
 1237              		.loc 1 316 0
 1238 03dc A847     		blx	r5
 1239              	.LVL181:
 1240 03de 0026     		movs	r6, #0
 1241              	.L136:
 1242              	.LVL182:
 286:_printf.c     ****                 for (cnt=0, i=(8-flagcnt)/2; i<4; i++){
 1243              		.loc 1 286 0
 1244 03e0 D845     		cmp	r8, fp
 1245 03e2 BDD0     		beq	.L214
 287:_printf.c     ****                         c = s[i];
 1246              		.loc 1 287 0
 1247 03e4 18F8013B 		ldrb	r3, [r8], #1	@ zero_extendqisi2
 1248              	.LVL183:
 291:_printf.c     ****                         lHex = ((c>>0)&0x0f);
 1249              		.loc 1 291 0
 1250 03e8 03F00F0A 		and	r10, r3, #15
 1251              	.LVL184:
 295:_printf.c     ****                         if (uHex!=0) leading_zero = false;
 1252              		.loc 1 295 0
 1253 03ec 1B09     		lsrs	r3, r3, #4
 1254              	.LVL185:
 1255 03ee E5D1     		bne	.L220
 1256              	.LVL186:
 1257              	.L123:
 300:_printf.c     ****                         if (leading_zero){
 1258              		.loc 1 300 0
 1259 03f0 002E     		cmp	r6, #0
 1260 03f2 39D0     		beq	.L124
 301:_printf.c     ****                                 if (flag0) print_byte('0');
 1261              		.loc 1 301 0
 1262 03f4 4CB1     		cbz	r4, .L128
 1263 03f6 3020     		movs	r0, #48
 1264 03f8 A847     		blx	r5
 1265              	.LVL187:
 307:_printf.c     ****                         if (lHex!=0) leading_zero = false;
 1266              		.loc 1 307 0
 1267 03fa BAF1000F 		cmp	r10, #0
 1268 03fe E7D1     		bne	.L221
 1269              	.LVL188:
 1270              	.L130:
 312:_printf.c     ****                         if (leading_zero){
 1271              		.loc 1 312 0
 1272 0400 7EB3     		cbz	r6, .L131
 313:_printf.c     ****                                 if (flag0) print_byte('0');
 1273              		.loc 1 313 0
 1274 0402 2CB1     		cbz	r4, .L135
 1275 0404 3020     		movs	r0, #48
 1276 0406 A847     		blx	r5
 1277              	.LVL189:
 1278 0408 EAE7     		b	.L136
 1279              	.LVL190:
 1280              	.L128:
 302:_printf.c     ****                                 else       print_byte(' ');
 1281              		.loc 1 302 0
 1282 040a 2020     		movs	r0, #32
 1283 040c A847     		blx	r5
 1284              	.LVL191:
 1285 040e DCE7     		b	.L129
 1286              	.LVL192:
 1287              	.L135:
 314:_printf.c     ****                                 else       print_byte(' ');
 1288              		.loc 1 314 0
 1289 0410 2020     		movs	r0, #32
 1290 0412 A847     		blx	r5
 1291              	.LVL193:
 1292 0414 E4E7     		b	.L136
 1293              	.LVL194:
 1294              	.L118:
 277:_printf.c     ****                                 if (flag0) print_byte('0');
 1295              		.loc 1 277 0
 1296 0416 3EB1     		cbz	r6, .L222
 1297 0418 3020     		movs	r0, #48
 1298 041a A847     		blx	r5
 1299              	.LVL195:
 1300 041c 4FF00109 		mov	r9, #1
 1301              	.LVL196:
 1302              	.L121:
 282:_printf.c     ****                         flagcnt--;
 1303              		.loc 1 282 0
 1304 0420 039B     		ldr	r3, [sp, #12]
 1305 0422 013B     		subs	r3, r3, #1
 1306 0424 0393     		str	r3, [sp, #12]
 1307 0426 B3E7     		b	.L117
 1308              	.LVL197:
 1309              	.L222:
 278:_printf.c     ****                                 else       print_byte(' ');
 1310              		.loc 1 278 0
 1311 0428 2020     		movs	r0, #32
 1312 042a A847     		blx	r5
 1313              	.LVL198:
 1314 042c 4FF00109 		mov	r9, #1
 1315 0430 F6E7     		b	.L121
 1316              	.LVL199:
 1317              	.L219:
 1318              	.LBE65:
 1319              	.LBE79:
 1320              	.LBB80:
 1321              	.LBB56:
 202:_printf.c     ****                 remainder = l%(Power(10, flagcnt));        // flagcnt보다 윗자리의 수는 걸러냄. 199
 1322              		.loc 1 202 0
 1323 0432 01F16631 		add	r1, r1, #1717986918
 1324 0436 81FB0B1A 		smull	r1, r10, r1, fp
 1325              	.LVL200:
 1326 043a 4FEAEB73 		asr	r3, fp, #31
 1327              	.LVL201:
 1328 043e C3EBAA0A 		rsb	r10, r3, r10, asr #2
 1329 0442 0AEB8A0A 		add	r10, r10, r10, lsl #2
 1330 0446 ABEB4A0A 		sub	r10, fp, r10, lsl #1
 1331              	.LVL202:
 1332 044a 6FF00103 		mvn	r3, #1
 1333 044e FCE6     		b	.L93
 1334              	.LVL203:
 1335              	.L157:
 1336              	.LBB50:
 1337              	.LBB47:
 350:_printf.c     ****         long retval=num;
 1338              		.loc 1 350 0
 1339 0450 4FF00A08 		mov	r8, #10
 1340 0454 02E7     		b	.L96
 1341              	.LVL204:
 1342              	.L145:
 1343              	.LBE47:
 1344              	.LBE50:
 1345              	.LBE56:
 1346              	.LBE80:
 1347              	.LBB81:
 1348              	.LBB66:
 335:_printf.c     ****                         if (lHex<10) lHex+='0';
 1349              		.loc 1 335 0
 1350 0456 04F13000 		add	r0, r4, #48
 1351 045a 8AE7     		b	.L149
 1352              	.LVL205:
 1353              	.L119:
 272:_printf.c     ****                         if (lHex<10) lHex+='0';
 1354              		.loc 1 272 0
 1355 045c 03F13000 		add	r0, r3, #48
 1356 0460 7EE6     		b	.L120
 1357              	.LVL206:
 1358              	.L131:
 308:_printf.c     ****                         if (lHex<10) lHex+='0';
 1359              		.loc 1 308 0
 1360 0462 0AF13000 		add	r0, r10, #48
 1361 0466 B9E7     		b	.L134
 1362              	.LVL207:
 1363              	.L124:
 296:_printf.c     ****                         if (uHex<10) uHex+='0';
 1364              		.loc 1 296 0
 1365 0468 03F13000 		add	r0, r3, #48
 1366 046c ABE7     		b	.L127
 1367              	.LVL208:
 1368              	.L140:
 330:_printf.c     ****                         if (uHex<10) uHex+='0';
 1369              		.loc 1 330 0
 1370 046e 03F13000 		add	r0, r3, #48
 1371 0472 69E7     		b	.L143
 1372              	.LBE66:
 1373              	.LBE81:
 1374              		.cfi_endproc
 1375              	.LFE6:
 1377              		.section	.text.delay_us,"ax",%progbits
 1378              		.align	2
 1379              		.global	delay_us
 1380              		.thumb
 1381              		.thumb_func
 1383              	delay_us:
 1384              	.LFB12:
 1385              		.file 2 "_delay.c"
   1:_delay.c      **** void delay_us(unsigned int us)
   2:_delay.c      **** {
 1386              		.loc 2 2 0
 1387              		.cfi_startproc
 1388              		@ args = 0, pretend = 0, frame = 0
 1389              		@ frame_needed = 0, uses_anonymous_args = 0
 1390              		@ link register save eliminated.
 1391              	.LVL209:
   3:_delay.c      ****     unsigned int i;
   4:_delay.c      **** 
   5:_delay.c      ****     while(us--)
 1392              		.loc 2 5 0
 1393 0000 431E     		subs	r3, r0, #1
 1394              	.LVL210:
 1395 0002 0028     		cmp	r0, #0
 1396 0004 41D0     		beq	.L225
 1397              	.LVL211:
 1398              	.L227:
   6:_delay.c      ****     {
   7:_delay.c      ****       asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");as
 1399              		.loc 2 7 0
 1400              	@ 7 "_delay.c" 1
 1401 0006 00BF     		nop
 1402              	
 1403              	@ 0 "" 2
 1404              	@ 7 "_delay.c" 1
 1405 0008 00BF     		nop
 1406              	
 1407              	@ 0 "" 2
 1408              	@ 7 "_delay.c" 1
 1409 000a 00BF     		nop
 1410              	
 1411              	@ 0 "" 2
 1412              	@ 7 "_delay.c" 1
 1413 000c 00BF     		nop
 1414              	
 1415              	@ 0 "" 2
 1416              	@ 7 "_delay.c" 1
 1417 000e 00BF     		nop
 1418              	
 1419              	@ 0 "" 2
 1420              	@ 7 "_delay.c" 1
 1421 0010 00BF     		nop
 1422              	
 1423              	@ 0 "" 2
 1424              	@ 7 "_delay.c" 1
 1425 0012 00BF     		nop
 1426              	
 1427              	@ 0 "" 2
 1428              	@ 7 "_delay.c" 1
 1429 0014 00BF     		nop
 1430              	
 1431              	@ 0 "" 2
   8:_delay.c      ****       asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");as
 1432              		.loc 2 8 0
 1433              	@ 8 "_delay.c" 1
 1434 0016 00BF     		nop
 1435              	
 1436              	@ 0 "" 2
 1437              	@ 8 "_delay.c" 1
 1438 0018 00BF     		nop
 1439              	
 1440              	@ 0 "" 2
 1441              	@ 8 "_delay.c" 1
 1442 001a 00BF     		nop
 1443              	
 1444              	@ 0 "" 2
 1445              	@ 8 "_delay.c" 1
 1446 001c 00BF     		nop
 1447              	
 1448              	@ 0 "" 2
 1449              	@ 8 "_delay.c" 1
 1450 001e 00BF     		nop
 1451              	
 1452              	@ 0 "" 2
 1453              	@ 8 "_delay.c" 1
 1454 0020 00BF     		nop
 1455              	
 1456              	@ 0 "" 2
 1457              	@ 8 "_delay.c" 1
 1458 0022 00BF     		nop
 1459              	
 1460              	@ 0 "" 2
 1461              	@ 8 "_delay.c" 1
 1462 0024 00BF     		nop
 1463              	
 1464              	@ 0 "" 2
   9:_delay.c      ****       asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");as
 1465              		.loc 2 9 0
 1466              	@ 9 "_delay.c" 1
 1467 0026 00BF     		nop
 1468              	
 1469              	@ 0 "" 2
 1470              	@ 9 "_delay.c" 1
 1471 0028 00BF     		nop
 1472              	
 1473              	@ 0 "" 2
 1474              	@ 9 "_delay.c" 1
 1475 002a 00BF     		nop
 1476              	
 1477              	@ 0 "" 2
 1478              	@ 9 "_delay.c" 1
 1479 002c 00BF     		nop
 1480              	
 1481              	@ 0 "" 2
 1482              	@ 9 "_delay.c" 1
 1483 002e 00BF     		nop
 1484              	
 1485              	@ 0 "" 2
 1486              	@ 9 "_delay.c" 1
 1487 0030 00BF     		nop
 1488              	
 1489              	@ 0 "" 2
 1490              	@ 9 "_delay.c" 1
 1491 0032 00BF     		nop
 1492              	
 1493              	@ 0 "" 2
 1494              	@ 9 "_delay.c" 1
 1495 0034 00BF     		nop
 1496              	
 1497              	@ 0 "" 2
  10:_delay.c      ****       asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");as
 1498              		.loc 2 10 0
 1499              	@ 10 "_delay.c" 1
 1500 0036 00BF     		nop
 1501              	
 1502              	@ 0 "" 2
 1503              	@ 10 "_delay.c" 1
 1504 0038 00BF     		nop
 1505              	
 1506              	@ 0 "" 2
 1507              	@ 10 "_delay.c" 1
 1508 003a 00BF     		nop
 1509              	
 1510              	@ 0 "" 2
 1511              	@ 10 "_delay.c" 1
 1512 003c 00BF     		nop
 1513              	
 1514              	@ 0 "" 2
 1515              	@ 10 "_delay.c" 1
 1516 003e 00BF     		nop
 1517              	
 1518              	@ 0 "" 2
 1519              	@ 10 "_delay.c" 1
 1520 0040 00BF     		nop
 1521              	
 1522              	@ 0 "" 2
 1523              	@ 10 "_delay.c" 1
 1524 0042 00BF     		nop
 1525              	
 1526              	@ 0 "" 2
 1527              	@ 10 "_delay.c" 1
 1528 0044 00BF     		nop
 1529              	
 1530              	@ 0 "" 2
  11:_delay.c      ****       asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");as
 1531              		.loc 2 11 0
 1532              	@ 11 "_delay.c" 1
 1533 0046 00BF     		nop
 1534              	
 1535              	@ 0 "" 2
 1536              	@ 11 "_delay.c" 1
 1537 0048 00BF     		nop
 1538              	
 1539              	@ 0 "" 2
 1540              	@ 11 "_delay.c" 1
 1541 004a 00BF     		nop
 1542              	
 1543              	@ 0 "" 2
 1544              	@ 11 "_delay.c" 1
 1545 004c 00BF     		nop
 1546              	
 1547              	@ 0 "" 2
 1548              	@ 11 "_delay.c" 1
 1549 004e 00BF     		nop
 1550              	
 1551              	@ 0 "" 2
 1552              	@ 11 "_delay.c" 1
 1553 0050 00BF     		nop
 1554              	
 1555              	@ 0 "" 2
 1556              	@ 11 "_delay.c" 1
 1557 0052 00BF     		nop
 1558              	
 1559              	@ 0 "" 2
 1560              	@ 11 "_delay.c" 1
 1561 0054 00BF     		nop
 1562              	
 1563              	@ 0 "" 2
  12:_delay.c      ****       asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");as
 1564              		.loc 2 12 0
 1565              	@ 12 "_delay.c" 1
 1566 0056 00BF     		nop
 1567              	
 1568              	@ 0 "" 2
 1569              	@ 12 "_delay.c" 1
 1570 0058 00BF     		nop
 1571              	
 1572              	@ 0 "" 2
 1573              	@ 12 "_delay.c" 1
 1574 005a 00BF     		nop
 1575              	
 1576              	@ 0 "" 2
 1577              	@ 12 "_delay.c" 1
 1578 005c 00BF     		nop
 1579              	
 1580              	@ 0 "" 2
 1581              	@ 12 "_delay.c" 1
 1582 005e 00BF     		nop
 1583              	
 1584              	@ 0 "" 2
 1585              	@ 12 "_delay.c" 1
 1586 0060 00BF     		nop
 1587              	
 1588              	@ 0 "" 2
 1589              	@ 12 "_delay.c" 1
 1590 0062 00BF     		nop
 1591              	
 1592              	@ 0 "" 2
 1593              	@ 12 "_delay.c" 1
 1594 0064 00BF     		nop
 1595              	
 1596              	@ 0 "" 2
  13:_delay.c      ****       asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");as
 1597              		.loc 2 13 0
 1598              	@ 13 "_delay.c" 1
 1599 0066 00BF     		nop
 1600              	
 1601              	@ 0 "" 2
 1602              	@ 13 "_delay.c" 1
 1603 0068 00BF     		nop
 1604              	
 1605              	@ 0 "" 2
 1606              	@ 13 "_delay.c" 1
 1607 006a 00BF     		nop
 1608              	
 1609              	@ 0 "" 2
 1610              	@ 13 "_delay.c" 1
 1611 006c 00BF     		nop
 1612              	
 1613              	@ 0 "" 2
 1614              	@ 13 "_delay.c" 1
 1615 006e 00BF     		nop
 1616              	
 1617              	@ 0 "" 2
 1618              	@ 13 "_delay.c" 1
 1619 0070 00BF     		nop
 1620              	
 1621              	@ 0 "" 2
 1622              	@ 13 "_delay.c" 1
 1623 0072 00BF     		nop
 1624              	
 1625              	@ 0 "" 2
 1626              	@ 13 "_delay.c" 1
 1627 0074 00BF     		nop
 1628              	
 1629              	@ 0 "" 2
  14:_delay.c      ****       asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");
 1630              		.loc 2 14 0
 1631              	@ 14 "_delay.c" 1
 1632 0076 00BF     		nop
 1633              	
 1634              	@ 0 "" 2
 1635              	@ 14 "_delay.c" 1
 1636 0078 00BF     		nop
 1637              	
 1638              	@ 0 "" 2
 1639              	@ 14 "_delay.c" 1
 1640 007a 00BF     		nop
 1641              	
 1642              	@ 0 "" 2
 1643              	@ 14 "_delay.c" 1
 1644 007c 00BF     		nop
 1645              	
 1646              	@ 0 "" 2
 1647              	@ 14 "_delay.c" 1
 1648 007e 00BF     		nop
 1649              	
 1650              	@ 0 "" 2
 1651              	@ 14 "_delay.c" 1
 1652 0080 00BF     		nop
 1653              	
 1654              	@ 0 "" 2
 1655              	@ 14 "_delay.c" 1
 1656 0082 00BF     		nop
 1657              	
 1658              	@ 0 "" 2
   5:_delay.c      ****     while(us--)
 1659              		.loc 2 5 0
 1660              		.thumb
 1661 0084 13F1FF33 		adds	r3, r3, #-1
 1662              	.LVL212:
 1663 0088 BDD2     		bcs	.L227
 1664              	.LVL213:
 1665              	.L225:
 1666 008a 7047     		bx	lr
 1667              		.cfi_endproc
 1668              	.LFE12:
 1670              		.section	.text.delay_ms,"ax",%progbits
 1671              		.align	2
 1672              		.global	delay_ms
 1673              		.thumb
 1674              		.thumb_func
 1676              	delay_ms:
 1677              	.LFB13:
  15:_delay.c      ****       //asm("nop\n");
  16:_delay.c      ****     }
  17:_delay.c      **** }
  18:_delay.c      **** 
  19:_delay.c      **** void delay_ms(unsigned int ms)
  20:_delay.c      **** {
 1678              		.loc 2 20 0
 1679              		.cfi_startproc
 1680              		@ args = 0, pretend = 0, frame = 0
 1681              		@ frame_needed = 0, uses_anonymous_args = 0
 1682              		@ link register save eliminated.
 1683              	.LVL214:
  21:_delay.c      ****     unsigned int i;
  22:_delay.c      **** 
  23:_delay.c      ****     while(ms--)
 1684              		.loc 2 23 0
 1685 0000 10F1FF30 		adds	r0, r0, #-1
 1686              	.LVL215:
 1687 0004 48D3     		bcc	.L235
 1688              	.LVL216:
 1689              	.L241:
 1690 0006 40F2E733 		movw	r3, #999
 1691              	.L239:
 1692              	.LVL217:
  24:_delay.c      ****     {
  25:_delay.c      ****         for(i=0;i<999;i++)
  26:_delay.c      ****         {
  27:_delay.c      ****          asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n")
 1693              		.loc 2 27 0 discriminator 2
 1694              	@ 27 "_delay.c" 1
 1695 000a 00BF     		nop
 1696              	
 1697              	@ 0 "" 2
 1698              	@ 27 "_delay.c" 1
 1699 000c 00BF     		nop
 1700              	
 1701              	@ 0 "" 2
 1702              	@ 27 "_delay.c" 1
 1703 000e 00BF     		nop
 1704              	
 1705              	@ 0 "" 2
 1706              	@ 27 "_delay.c" 1
 1707 0010 00BF     		nop
 1708              	
 1709              	@ 0 "" 2
 1710              	@ 27 "_delay.c" 1
 1711 0012 00BF     		nop
 1712              	
 1713              	@ 0 "" 2
 1714              	@ 27 "_delay.c" 1
 1715 0014 00BF     		nop
 1716              	
 1717              	@ 0 "" 2
 1718              	@ 27 "_delay.c" 1
 1719 0016 00BF     		nop
 1720              	
 1721              	@ 0 "" 2
 1722              	@ 27 "_delay.c" 1
 1723 0018 00BF     		nop
 1724              	
 1725              	@ 0 "" 2
  28:_delay.c      ****          asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n")
 1726              		.loc 2 28 0 discriminator 2
 1727              	@ 28 "_delay.c" 1
 1728 001a 00BF     		nop
 1729              	
 1730              	@ 0 "" 2
 1731              	@ 28 "_delay.c" 1
 1732 001c 00BF     		nop
 1733              	
 1734              	@ 0 "" 2
 1735              	@ 28 "_delay.c" 1
 1736 001e 00BF     		nop
 1737              	
 1738              	@ 0 "" 2
 1739              	@ 28 "_delay.c" 1
 1740 0020 00BF     		nop
 1741              	
 1742              	@ 0 "" 2
 1743              	@ 28 "_delay.c" 1
 1744 0022 00BF     		nop
 1745              	
 1746              	@ 0 "" 2
 1747              	@ 28 "_delay.c" 1
 1748 0024 00BF     		nop
 1749              	
 1750              	@ 0 "" 2
 1751              	@ 28 "_delay.c" 1
 1752 0026 00BF     		nop
 1753              	
 1754              	@ 0 "" 2
 1755              	@ 28 "_delay.c" 1
 1756 0028 00BF     		nop
 1757              	
 1758              	@ 0 "" 2
  29:_delay.c      ****          asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n")
 1759              		.loc 2 29 0 discriminator 2
 1760              	@ 29 "_delay.c" 1
 1761 002a 00BF     		nop
 1762              	
 1763              	@ 0 "" 2
 1764              	@ 29 "_delay.c" 1
 1765 002c 00BF     		nop
 1766              	
 1767              	@ 0 "" 2
 1768              	@ 29 "_delay.c" 1
 1769 002e 00BF     		nop
 1770              	
 1771              	@ 0 "" 2
 1772              	@ 29 "_delay.c" 1
 1773 0030 00BF     		nop
 1774              	
 1775              	@ 0 "" 2
 1776              	@ 29 "_delay.c" 1
 1777 0032 00BF     		nop
 1778              	
 1779              	@ 0 "" 2
 1780              	@ 29 "_delay.c" 1
 1781 0034 00BF     		nop
 1782              	
 1783              	@ 0 "" 2
 1784              	@ 29 "_delay.c" 1
 1785 0036 00BF     		nop
 1786              	
 1787              	@ 0 "" 2
 1788              	@ 29 "_delay.c" 1
 1789 0038 00BF     		nop
 1790              	
 1791              	@ 0 "" 2
  30:_delay.c      ****          asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n")
 1792              		.loc 2 30 0 discriminator 2
 1793              	@ 30 "_delay.c" 1
 1794 003a 00BF     		nop
 1795              	
 1796              	@ 0 "" 2
 1797              	@ 30 "_delay.c" 1
 1798 003c 00BF     		nop
 1799              	
 1800              	@ 0 "" 2
 1801              	@ 30 "_delay.c" 1
 1802 003e 00BF     		nop
 1803              	
 1804              	@ 0 "" 2
 1805              	@ 30 "_delay.c" 1
 1806 0040 00BF     		nop
 1807              	
 1808              	@ 0 "" 2
 1809              	@ 30 "_delay.c" 1
 1810 0042 00BF     		nop
 1811              	
 1812              	@ 0 "" 2
 1813              	@ 30 "_delay.c" 1
 1814 0044 00BF     		nop
 1815              	
 1816              	@ 0 "" 2
 1817              	@ 30 "_delay.c" 1
 1818 0046 00BF     		nop
 1819              	
 1820              	@ 0 "" 2
 1821              	@ 30 "_delay.c" 1
 1822 0048 00BF     		nop
 1823              	
 1824              	@ 0 "" 2
  31:_delay.c      ****          asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n")
 1825              		.loc 2 31 0 discriminator 2
 1826              	@ 31 "_delay.c" 1
 1827 004a 00BF     		nop
 1828              	
 1829              	@ 0 "" 2
 1830              	@ 31 "_delay.c" 1
 1831 004c 00BF     		nop
 1832              	
 1833              	@ 0 "" 2
 1834              	@ 31 "_delay.c" 1
 1835 004e 00BF     		nop
 1836              	
 1837              	@ 0 "" 2
 1838              	@ 31 "_delay.c" 1
 1839 0050 00BF     		nop
 1840              	
 1841              	@ 0 "" 2
 1842              	@ 31 "_delay.c" 1
 1843 0052 00BF     		nop
 1844              	
 1845              	@ 0 "" 2
 1846              	@ 31 "_delay.c" 1
 1847 0054 00BF     		nop
 1848              	
 1849              	@ 0 "" 2
 1850              	@ 31 "_delay.c" 1
 1851 0056 00BF     		nop
 1852              	
 1853              	@ 0 "" 2
 1854              	@ 31 "_delay.c" 1
 1855 0058 00BF     		nop
 1856              	
 1857              	@ 0 "" 2
  32:_delay.c      ****          asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n")
 1858              		.loc 2 32 0 discriminator 2
 1859              	@ 32 "_delay.c" 1
 1860 005a 00BF     		nop
 1861              	
 1862              	@ 0 "" 2
 1863              	@ 32 "_delay.c" 1
 1864 005c 00BF     		nop
 1865              	
 1866              	@ 0 "" 2
 1867              	@ 32 "_delay.c" 1
 1868 005e 00BF     		nop
 1869              	
 1870              	@ 0 "" 2
 1871              	@ 32 "_delay.c" 1
 1872 0060 00BF     		nop
 1873              	
 1874              	@ 0 "" 2
 1875              	@ 32 "_delay.c" 1
 1876 0062 00BF     		nop
 1877              	
 1878              	@ 0 "" 2
 1879              	@ 32 "_delay.c" 1
 1880 0064 00BF     		nop
 1881              	
 1882              	@ 0 "" 2
 1883              	@ 32 "_delay.c" 1
 1884 0066 00BF     		nop
 1885              	
 1886              	@ 0 "" 2
 1887              	@ 32 "_delay.c" 1
 1888 0068 00BF     		nop
 1889              	
 1890              	@ 0 "" 2
  33:_delay.c      ****          asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n")
 1891              		.loc 2 33 0 discriminator 2
 1892              	@ 33 "_delay.c" 1
 1893 006a 00BF     		nop
 1894              	
 1895              	@ 0 "" 2
 1896              	@ 33 "_delay.c" 1
 1897 006c 00BF     		nop
 1898              	
 1899              	@ 0 "" 2
 1900              	@ 33 "_delay.c" 1
 1901 006e 00BF     		nop
 1902              	
 1903              	@ 0 "" 2
 1904              	@ 33 "_delay.c" 1
 1905 0070 00BF     		nop
 1906              	
 1907              	@ 0 "" 2
 1908              	@ 33 "_delay.c" 1
 1909 0072 00BF     		nop
 1910              	
 1911              	@ 0 "" 2
 1912              	@ 33 "_delay.c" 1
 1913 0074 00BF     		nop
 1914              	
 1915              	@ 0 "" 2
 1916              	@ 33 "_delay.c" 1
 1917 0076 00BF     		nop
 1918              	
 1919              	@ 0 "" 2
 1920              	@ 33 "_delay.c" 1
 1921 0078 00BF     		nop
 1922              	
 1923              	@ 0 "" 2
  34:_delay.c      ****          asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n");asm("nop\n")
 1924              		.loc 2 34 0 discriminator 2
 1925              	@ 34 "_delay.c" 1
 1926 007a 00BF     		nop
 1927              	
 1928              	@ 0 "" 2
 1929              	@ 34 "_delay.c" 1
 1930 007c 00BF     		nop
 1931              	
 1932              	@ 0 "" 2
 1933              	@ 34 "_delay.c" 1
 1934 007e 00BF     		nop
 1935              	
 1936              	@ 0 "" 2
 1937              	@ 34 "_delay.c" 1
 1938 0080 00BF     		nop
 1939              	
 1940              	@ 0 "" 2
 1941              	@ 34 "_delay.c" 1
 1942 0082 00BF     		nop
 1943              	
 1944              	@ 0 "" 2
 1945              	@ 34 "_delay.c" 1
 1946 0084 00BF     		nop
 1947              	
 1948              	@ 0 "" 2
 1949              	@ 34 "_delay.c" 1
 1950 0086 00BF     		nop
 1951              	
 1952              	@ 0 "" 2
 1953              	@ 34 "_delay.c" 1
 1954 0088 00BF     		nop
 1955              	
 1956              	@ 0 "" 2
  35:_delay.c      ****          asm("nop\n");asm("nop\n");
 1957              		.loc 2 35 0 discriminator 2
 1958              	@ 35 "_delay.c" 1
 1959 008a 00BF     		nop
 1960              	
 1961              	@ 0 "" 2
 1962              	@ 35 "_delay.c" 1
 1963 008c 00BF     		nop
 1964              	
 1965              	@ 0 "" 2
 1966              	.LVL218:
  25:_delay.c      ****         for(i=0;i<999;i++)
 1967              		.loc 2 25 0 discriminator 2
 1968              		.thumb
 1969 008e 013B     		subs	r3, r3, #1
 1970              	.LVL219:
 1971 0090 BBD1     		bne	.L239
 1972              	.LVL220:
  23:_delay.c      ****     while(ms--)
 1973              		.loc 2 23 0
 1974 0092 10F1FF30 		adds	r0, r0, #-1
 1975              	.LVL221:
 1976 0096 B6D2     		bcs	.L241
 1977              	.LVL222:
 1978              	.L235:
 1979 0098 7047     		bx	lr
 1980              		.cfi_endproc
 1981              	.LFE13:
 1983 009a 00BF     		.section	.text.init_TIM3,"ax",%progbits
 1984              		.align	2
 1985              		.global	init_TIM3
 1986              		.thumb
 1987              		.thumb_func
 1989              	init_TIM3:
 1990              	.LFB14:
 1991              		.file 3 "main.c"
   1:main.c        **** //======================================================================================
   2:main.c        **** //
   3:main.c        **** //	DC Motor Control by PWM
   4:main.c        **** //
   5:main.c        **** //										 by GroundZero   2014. 1. 22.
   6:main.c        **** //
   7:main.c        **** //======================================================================================
   8:main.c        **** #include "stm32md_reg.c"
   9:main.c        **** #include "_printf.c"
  10:main.c        **** #include "_delay.c"
  11:main.c        **** 
  12:main.c        **** #define MAX 400
  13:main.c        **** #define MIN 260
  14:main.c        **** 
  15:main.c        **** void init_TIM3(void)
  16:main.c        **** {								// CNF[1:0]=10(AF output), MODE[1:0]=11(Max output 50MHz) 1011
 1992              		.loc 3 16 0
 1993              		.cfi_startproc
 1994              		@ args = 0, pretend = 0, frame = 0
 1995              		@ frame_needed = 0, uses_anonymous_args = 0
 1996              		@ link register save eliminated.
  17:main.c        **** 	GPIOB_CRH	|= ( 0xb<<0)	// set PB8 as AF output (0xb = 1011)	TIM3_CH1
 1997              		.loc 3 17 0
 1998 0000 144A     		ldr	r2, .L243
  16:main.c        **** {								// CNF[1:0]=10(AF output), MODE[1:0]=11(Max output 50MHz) 1011
 1999              		.loc 3 16 0
 2000 0002 70B4     		push	{r4, r5, r6}
 2001              	.LCFI8:
 2002              		.cfi_def_cfa_offset 12
 2003              		.cfi_offset 4, -12
 2004              		.cfi_offset 5, -8
 2005              		.cfi_offset 6, -4
 2006              		.loc 3 17 0
 2007 0004 1668     		ldr	r6, [r2]
  18:main.c        **** 				|  ( 0xb<<1);	// set PB9 as AF output (0xb = 1011)	TIM3_CH2
  19:main.c        **** //	GPIOA_CRL	|= ( 0xb<<24)	// set PA6 as AF output (0xb = 1011)	TIM3_CH1
  20:main.c        **** //				|  ( 0xb<<28);	// set PA7 as AF output (0xb = 1011)	TIM3_CH2
  21:main.c        **** 	
  22:main.c        **** //	GPIOB_CRL	|= ( 0xb<< 0)	// set PB0 as AF output (0xb = 1011)	TIM3_CH3
  23:main.c        **** //				|  ( 0xb<< 4);	// set PB1 as AF output (0xb = 1011)	TIM3_CH4
  24:main.c        **** 
  25:main.c        **** //	RCC_APB1ENR	|= ( 0x1<< 2);	// bit0 - TIM2 Clock Enable bit
  26:main.c        **** 	
  27:main.c        **** //	TIM3_PSC	 = 8;			// 72000000 / (8+1) = 8000000 =  8MHz, T = 1/8000000 = 0.000000125 = 0.125us
  28:main.c        **** 	TIM4_PSC	 = 8;			// 72000000 / (8+1) = 8000000 =  8MHz, T = 1/8000000 = 0.000000125 = 0.125us
 2008              		.loc 3 28 0
 2009 0006 144C     		ldr	r4, .L243+4
  29:main.c        **** 							
  30:main.c        **** //	TIM3_ARR	 = 400-1;		// 0.000000125 * 400 = 0.00005, F = 1 / 0.00005 = 20000Hz = 20KHz
  31:main.c        **** 	TIM4_ARR	 = 400-1;		// 0.000000125 * 400 = 0.00005, F = 1 / 0.00005 = 20000Hz = 20KHz
 2010              		.loc 3 31 0
 2011 0008 1449     		ldr	r1, .L243+8
  32:main.c        **** 	
  33:main.c        **** //	TIM3_CR1	|= ( 0x1<< 4);	// set DIR (Direction - down count)
  34:main.c        **** 	TIM4_CR1	|= ( 0x1<< 4);	// set DIR (Direction - down count)
 2012              		.loc 3 34 0
 2013 000a 154B     		ldr	r3, .L243+12
  17:main.c        **** 	GPIOB_CRH	|= ( 0xb<<0)	// set PB8 as AF output (0xb = 1011)	TIM3_CH1
 2014              		.loc 3 17 0
 2015 000c 46F01F06 		orr	r6, r6, #31
  28:main.c        **** 	TIM4_PSC	 = 8;			// 72000000 / (8+1) = 8000000 =  8MHz, T = 1/8000000 = 0.000000125 = 0.125us
 2016              		.loc 3 28 0
 2017 0010 0825     		movs	r5, #8
  31:main.c        **** 	TIM4_ARR	 = 400-1;		// 0.000000125 * 400 = 0.00005, F = 1 / 0.00005 = 20000Hz = 20KHz
 2018              		.loc 3 31 0
 2019 0012 40F28F10 		movw	r0, #399
  17:main.c        **** 	GPIOB_CRH	|= ( 0xb<<0)	// set PB8 as AF output (0xb = 1011)	TIM3_CH1
 2020              		.loc 3 17 0
 2021 0016 1660     		str	r6, [r2]
  28:main.c        **** 	TIM4_PSC	 = 8;			// 72000000 / (8+1) = 8000000 =  8MHz, T = 1/8000000 = 0.000000125 = 0.125us
 2022              		.loc 3 28 0
 2023 0018 2560     		str	r5, [r4]
  31:main.c        **** 	TIM4_ARR	 = 400-1;		// 0.000000125 * 400 = 0.00005, F = 1 / 0.00005 = 20000Hz = 20KHz
 2024              		.loc 3 31 0
 2025 001a 0860     		str	r0, [r1]
 2026              		.loc 3 34 0
 2027 001c 1A68     		ldr	r2, [r3]
  35:main.c        **** 				
  36:main.c        **** //	TIM3_CCMR1	|= ( 0x1<< 3)	// ch1: preload enable
  37:main.c        **** //				|  ( 0x6<< 4)	// ch1: OC Mode = PWM mode1 ( 110 )
  38:main.c        **** //				|  ( 0x1<<11)	// ch2: preload enable
  39:main.c        **** //				|  ( 0x6<<12);	// ch2: OC Mode = PWM mode1 ( 110 )
  40:main.c        **** 
  41:main.c        **** //	TIM3_CCMR2	|= ( 0x1<< 3)	// ch3: compare fast & preload enable(11)
  42:main.c        **** //				|  ( 0x6<< 4)	// ch3: OC Mode = PWM mode1 ( 110 )
  43:main.c        **** //				|  ( 0x1<<11)	// ch4: compare fast & preload enable(11)
  44:main.c        **** //				|  ( 0x6<<12);	// ch4: OC Mode = PWM mode1 ( 110 )
  45:main.c        **** 
  46:main.c        **** 
  47:main.c        **** 	TIM4_CCMR2	|= ( 0x1<< 3)	// ch3: compare fast & preload enable(11)
 2028              		.loc 3 47 0
 2029 001e 1148     		ldr	r0, .L243+16
  34:main.c        **** 	TIM4_CR1	|= ( 0x1<< 4);	// set DIR (Direction - down count)
 2030              		.loc 3 34 0
 2031 0020 42F01002 		orr	r2, r2, #16
 2032 0024 1A60     		str	r2, [r3]
 2033              		.loc 3 47 0
 2034 0026 0268     		ldr	r2, [r0]
 2035 0028 42F4D042 		orr	r2, r2, #26624
 2036 002c 42F06802 		orr	r2, r2, #104
 2037 0030 0260     		str	r2, [r0]
  48:main.c        **** 				|  ( 0x6<< 4)	// ch3: OC Mode = PWM mode1 ( 110 )
  49:main.c        **** 				|  ( 0x1<<11)	// ch4: compare fast & preload enable(11)
  50:main.c        **** 				|  ( 0x6<<12);	// ch4: OC Mode = PWM mode1 ( 110 )
  51:main.c        **** 
  52:main.c        **** 
  53:main.c        **** 
  54:main.c        **** //	TIM3_CCER	|= ( 0x1<< 0)	// ch1: output enable
  55:main.c        **** //				|  ( 0x1<< 4);	// ch2: output enable
  56:main.c        **** //				|  ( 0x1<< 8)	// ch3: output enable
  57:main.c        **** //				|  ( 0x1<<12);	// ch4: output enable
  58:main.c        **** 
  59:main.c        **** 
  60:main.c        **** 	TIM4_CCER	|= ( 0x1<< 8)	// ch3: output enable
 2038              		.loc 3 60 0
 2039 0032 51F80C5C 		ldr	r5, [r1, #-12]
  61:main.c        **** 				|  ( 0x1<< 12);	// ch4: output enable
  62:main.c        **** 
  63:main.c        **** 	
  64:main.c        **** //	TIM3_CCR1	 = (280-1);		// ch1: 65% duty
  65:main.c        **** //	TIM3_CCR2	 = (280-1);		// ch2: 65% duty
  66:main.c        **** //	TIM3_CCR3	 = (280-1);		// ch3: 65% duty
  67:main.c        **** //	TIM3_CCR4	 = (280-1);		// ch4: 65% duty
  68:main.c        **** 
  69:main.c        **** 	TIM4_CCR3	 = (280-1);		// ch3: 65% duty
 2040              		.loc 3 69 0
 2041 0036 40F21712 		movw	r2, #279
  60:main.c        **** 	TIM4_CCER	|= ( 0x1<< 8)	// ch3: output enable
 2042              		.loc 3 60 0
 2043 003a 45F48855 		orr	r5, r5, #4352
 2044 003e 41F80C5C 		str	r5, [r1, #-12]
 2045              		.loc 3 69 0
 2046 0042 6261     		str	r2, [r4, #20]
  70:main.c        **** 	TIM4_CCR4	 = (280-1);		// ch4: 65% duty
 2047              		.loc 3 70 0
 2048 0044 4261     		str	r2, [r0, #20]
  71:main.c        **** 
  72:main.c        **** 	
  73:main.c        **** //	TIM3_CR1	|= ( 0x1<< 7)	// set APRE(Auto Reload Preload Enable)
  74:main.c        **** //				|  ( 0x1<< 0);	// TIM3 Counter Enable
  75:main.c        **** 	TIM4_CR1	|= ( 0x1<< 7)	// set APRE(Auto Reload Preload Enable)
 2049              		.loc 3 75 0
 2050 0046 1A68     		ldr	r2, [r3]
  76:main.c        **** 				|  ( 0x1<< 0);	// TIM3 Counter Enable
  77:main.c        **** }
 2051              		.loc 3 77 0
 2052 0048 70BC     		pop	{r4, r5, r6}
  75:main.c        **** 	TIM4_CR1	|= ( 0x1<< 7)	// set APRE(Auto Reload Preload Enable)
 2053              		.loc 3 75 0
 2054 004a 42F08102 		orr	r2, r2, #129
 2055 004e 1A60     		str	r2, [r3]
 2056              		.loc 3 77 0
 2057 0050 7047     		bx	lr
 2058              	.L244:
 2059 0052 00BF     		.align	2
 2060              	.L243:
 2061 0054 040C0140 		.word	1073810436
 2062 0058 28080040 		.word	1073743912
 2063 005c 2C080040 		.word	1073743916
 2064 0060 00080040 		.word	1073743872
 2065 0064 1C080040 		.word	1073743900
 2066              		.cfi_endproc
 2067              	.LFE14:
 2069              		.section	.text.change_duty31,"ax",%progbits
 2070              		.align	2
 2071              		.global	change_duty31
 2072              		.thumb
 2073              		.thumb_func
 2075              	change_duty31:
 2076              	.LFB15:
  78:main.c        **** 
  79:main.c        **** void change_duty31(unsigned short duty)
  80:main.c        **** {
 2077              		.loc 3 80 0
 2078              		.cfi_startproc
 2079              		@ args = 0, pretend = 0, frame = 0
 2080              		@ frame_needed = 0, uses_anonymous_args = 0
 2081              		@ link register save eliminated.
 2082              	.LVL223:
  81:main.c        **** //	TIM3_CCR1	 = duty-1;		// change duty of TIM3_CH1
  82:main.c        **** 	TIM4_CCR3	 = duty-1;		// change duty of TIM3_CH1
 2083              		.loc 3 82 0
 2084 0000 014B     		ldr	r3, .L246
 2085 0002 0138     		subs	r0, r0, #1
 2086              	.LVL224:
 2087 0004 1860     		str	r0, [r3]
 2088 0006 7047     		bx	lr
 2089              	.L247:
 2090              		.align	2
 2091              	.L246:
 2092 0008 3C080040 		.word	1073743932
 2093              		.cfi_endproc
 2094              	.LFE15:
 2096              		.section	.text.change_duty32,"ax",%progbits
 2097              		.align	2
 2098              		.global	change_duty32
 2099              		.thumb
 2100              		.thumb_func
 2102              	change_duty32:
 2103              	.LFB16:
  83:main.c        **** }
  84:main.c        **** 
  85:main.c        **** void change_duty32(unsigned short duty)
  86:main.c        **** {
 2104              		.loc 3 86 0
 2105              		.cfi_startproc
 2106              		@ args = 0, pretend = 0, frame = 0
 2107              		@ frame_needed = 0, uses_anonymous_args = 0
 2108              		@ link register save eliminated.
 2109              	.LVL225:
  87:main.c        **** //	TIM3_CCR2	 = duty-1;		// change duty of TIM3_CH2
  88:main.c        **** 	TIM4_CCR4	 = duty-1;		// change duty of TIM3_CH2
 2110              		.loc 3 88 0
 2111 0000 014B     		ldr	r3, .L249
 2112 0002 0138     		subs	r0, r0, #1
 2113              	.LVL226:
 2114 0004 1860     		str	r0, [r3]
 2115 0006 7047     		bx	lr
 2116              	.L250:
 2117              		.align	2
 2118              	.L249:
 2119 0008 30080040 		.word	1073743920
 2120              		.cfi_endproc
 2121              	.LFE16:
 2123              		.section	.text.startup.main,"ax",%progbits
 2124              		.align	2
 2125              		.global	main
 2126              		.thumb
 2127              		.thumb_func
 2129              	main:
 2130              	.LFB17:
  89:main.c        **** }
  90:main.c        **** 
  91:main.c        **** 
  92:main.c        **** #if 0
  93:main.c        **** void change_duty33(unsigned short duty)
  94:main.c        **** {
  95:main.c        **** 	TIM3_CCR3	 = duty-1;		// change duty of TIM3_CH3
  96:main.c        **** }
  97:main.c        **** 
  98:main.c        **** void change_duty34(unsigned short duty)
  99:main.c        **** {
 100:main.c        **** 	TIM3_CCR4	 = duty-1;		// change duty of TIM3_CH4
 101:main.c        **** }
 102:main.c        **** #endif
 103:main.c        **** 
 104:main.c        **** 
 105:main.c        **** int main(void)
 106:main.c        **** {
 2131              		.loc 3 106 0
 2132              		.cfi_startproc
 2133              		@ args = 0, pretend = 0, frame = 0
 2134              		@ frame_needed = 0, uses_anonymous_args = 0
 2135              	.LVL227:
 2136 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2137              	.LCFI9:
 2138              		.cfi_def_cfa_offset 24
 2139              		.cfi_offset 3, -24
 2140              		.cfi_offset 4, -20
 2141              		.cfi_offset 5, -16
 2142              		.cfi_offset 6, -12
 2143              		.cfi_offset 7, -8
 2144              		.cfi_offset 14, -4
 107:main.c        **** 	unsigned short duty = MAX;
 108:main.c        **** 	printf("Moror_Ctrl\n");
 2145              		.loc 3 108 0
 2146 0002 2C48     		ldr	r0, .L265
 2147 0004 2C4F     		ldr	r7, .L265+4
 2148 0006 B847     		blx	r7
 2149              	.LVL228:
 109:main.c        **** 
 110:main.c        **** 	init_TIM3();
 2150              		.loc 3 110 0
 2151 0008 2C4B     		ldr	r3, .L265+8
 2152 000a 9847     		blx	r3
 2153              	.LVL229:
 2154              	.LBB82:
 2155              	.LBB83:
  51:_printf.c     ****     while( !((*(volatile unsigned long *) 0x40013800) & 0x20) ) ;
 2156              		.loc 1 51 0
 2157 000c 2C4C     		ldr	r4, .L265+12
  52:_printf.c     ****     return (char) (*(volatile unsigned long *) 0x40013804 & 0xff);
 2158              		.loc 1 52 0
 2159 000e 2D4E     		ldr	r6, .L265+16
 2160              	.LBE83:
 2161              	.LBE82:
 111:main.c        **** 
 112:main.c        **** 	while(1)
 113:main.c        **** 	{
 114:main.c        **** 		switch(get_byte())
 115:main.c        **** 		{
 116:main.c        **** 			case('c'):
 117:main.c        **** 				printf("forward\n");
 118:main.c        **** //				GPIOA_ODR	&= (~0xf << 2 );	// PA5,4,3,2 = 0000 = 0x0
 119:main.c        **** //				GPIOA_ODR	|= ( 0x5 << 2 );	// PA5,4,3,2 = 0101 = 0x5
 120:main.c        **** 				GPIOB_ODR	&= (~0xf << 4 );	// PA5,4,3,2 = 0000 = 0x0
 121:main.c        **** 				GPIOB_ODR	|= ( 0x5 << 4 );	// PA5,4,3,2 = 0101 = 0x5
 122:main.c        **** 				break;
 123:main.c        **** 
 124:main.c        **** 			case('d'):
 125:main.c        **** 				printf("back\n");
 126:main.c        **** //				GPIOA_ODR	&= (~0xf << 2 );	// PA5,4,3,2 = 0000 = 0x0
 127:main.c        **** //				GPIOA_ODR	|= ( 0xa << 2 );	// PA5,4,3,2 = 1010 = 0xa
 128:main.c        **** 				GPIOB_ODR	&= (~0xf << 4 );	// PA5,4,3,2 = 0000 = 0x0
 129:main.c        **** 				GPIOB_ODR	|= ( 0xa << 4 );	// PA5,4,3,2 = 1010 = 0xa
 130:main.c        **** 				break;
 131:main.c        **** 
 132:main.c        **** 			case('a'):
 133:main.c        **** 				printf("turn left\n");
 134:main.c        **** //				GPIOA_ODR	&= (~0xf << 2 );	// PA5,4,3,2 = 0000 = 0x0
 135:main.c        **** //				GPIOA_ODR	|= ( 0x6 << 2 );	// PA5,4,3,2 = 1001 = 0x9
 136:main.c        **** 				GPIOB_ODR	&= (~0xf << 4 );	// PA5,4,3,2 = 0000 = 0x0
 137:main.c        **** 				GPIOB_ODR	|= ( 0x6 << 4 );	// PA5,4,3,2 = 1001 = 0x9
 138:main.c        **** 				break;
 139:main.c        **** 
 140:main.c        **** 			case('b'):
 141:main.c        **** 				printf("turn right\n");
 142:main.c        **** //				GPIOA_ODR	&= (~0xf << 2 );	// PA5,4,3,2 = 0000 = 0x0
 143:main.c        **** //				GPIOA_ODR	|= ( 0x9 << 2 );	// PA5,4,3,2 = 0110 = 0x6				
 144:main.c        **** 				GPIOB_ODR	&= (~0xf << 4 );	// PA5,4,3,2 = 0000 = 0x0
 145:main.c        **** 				GPIOB_ODR	|= ( 0x9 << 4 );	// PA5,4,3,2 = 0110 = 0x6				
 146:main.c        **** 				break;
 147:main.c        **** 				
 148:main.c        **** 			case('i'):
 149:main.c        **** 				printf("stop\n");
 150:main.c        **** //				GPIOA_ODR	|= ( 0xf << 2 );	// PA5,4,3,2 = 1111 = 0xf
 151:main.c        **** 				GPIOB_ODR	|= ( 0xf << 4 );	// PA5,4,3,2 = 1111 = 0xf
 2162              		.loc 3 151 0
 2163 0010 2D4D     		ldr	r5, .L265+20
 2164              	.L253:
 2165              	.LBB85:
 2166              	.LBB84:
  51:_printf.c     ****     while( !((*(volatile unsigned long *) 0x40013800) & 0x20) ) ;
 2167              		.loc 1 51 0
 2168 0012 2368     		ldr	r3, [r4]
 2169 0014 9B06     		lsls	r3, r3, #26
 2170 0016 FCD5     		bpl	.L253
  52:_printf.c     ****     return (char) (*(volatile unsigned long *) 0x40013804 & 0xff);
 2171              		.loc 1 52 0
 2172 0018 3368     		ldr	r3, [r6]
 2173              	.LBE84:
 2174              	.LBE85:
 114:main.c        **** 		switch(get_byte())
 2175              		.loc 3 114 0
 2176 001a DBB2     		uxtb	r3, r3
 2177 001c 613B     		subs	r3, r3, #97
 2178 001e 082B     		cmp	r3, #8
 2179 0020 F7D8     		bhi	.L253
 2180 0022 01A2     		adr	r2, .L256
 2181 0024 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 2182              		.p2align 2
 2183              	.L256:
 2184 0028 9D000000 		.word	.L255+1
 2185 002c 87000000 		.word	.L257+1
 2186 0030 71000000 		.word	.L258+1
 2187 0034 5B000000 		.word	.L259+1
 2188 0038 13000000 		.word	.L253+1
 2189 003c 13000000 		.word	.L253+1
 2190 0040 13000000 		.word	.L253+1
 2191 0044 13000000 		.word	.L253+1
 2192 0048 4D000000 		.word	.L260+1
 2193              	.L260:
 149:main.c        **** 				printf("stop\n");
 2194              		.loc 3 149 0
 2195 004c 1F48     		ldr	r0, .L265+24
 2196 004e B847     		blx	r7
 2197              	.LVL230:
 2198              		.loc 3 151 0
 2199 0050 2B68     		ldr	r3, [r5]
 2200 0052 43F0F003 		orr	r3, r3, #240
 2201 0056 2B60     		str	r3, [r5]
 152:main.c        **** 				
 153:main.c        **** 				break;
 2202              		.loc 3 153 0
 2203 0058 DBE7     		b	.L253
 2204              	.L259:
 125:main.c        **** 				printf("back\n");
 2205              		.loc 3 125 0
 2206 005a 1D48     		ldr	r0, .L265+28
 2207 005c B847     		blx	r7
 2208              	.LVL231:
 128:main.c        **** 				GPIOB_ODR	&= (~0xf << 4 );	// PA5,4,3,2 = 0000 = 0x0
 2209              		.loc 3 128 0
 2210 005e 2B68     		ldr	r3, [r5]
 2211 0060 23F0FF03 		bic	r3, r3, #255
 2212 0064 2B60     		str	r3, [r5]
 129:main.c        **** 				GPIOB_ODR	|= ( 0xa << 4 );	// PA5,4,3,2 = 1010 = 0xa
 2213              		.loc 3 129 0
 2214 0066 2B68     		ldr	r3, [r5]
 2215 0068 43F0A003 		orr	r3, r3, #160
 2216 006c 2B60     		str	r3, [r5]
 130:main.c        **** 				break;
 2217              		.loc 3 130 0
 2218 006e D0E7     		b	.L253
 2219              	.L258:
 117:main.c        **** 				printf("forward\n");
 2220              		.loc 3 117 0
 2221 0070 1848     		ldr	r0, .L265+32
 2222 0072 B847     		blx	r7
 2223              	.LVL232:
 120:main.c        **** 				GPIOB_ODR	&= (~0xf << 4 );	// PA5,4,3,2 = 0000 = 0x0
 2224              		.loc 3 120 0
 2225 0074 2B68     		ldr	r3, [r5]
 2226 0076 23F0FF03 		bic	r3, r3, #255
 2227 007a 2B60     		str	r3, [r5]
 121:main.c        **** 				GPIOB_ODR	|= ( 0x5 << 4 );	// PA5,4,3,2 = 0101 = 0x5
 2228              		.loc 3 121 0
 2229 007c 2B68     		ldr	r3, [r5]
 2230 007e 43F05003 		orr	r3, r3, #80
 2231 0082 2B60     		str	r3, [r5]
 122:main.c        **** 				break;
 2232              		.loc 3 122 0
 2233 0084 C5E7     		b	.L253
 2234              	.L257:
 141:main.c        **** 				printf("turn right\n");
 2235              		.loc 3 141 0
 2236 0086 1448     		ldr	r0, .L265+36
 2237 0088 B847     		blx	r7
 2238              	.LVL233:
 144:main.c        **** 				GPIOB_ODR	&= (~0xf << 4 );	// PA5,4,3,2 = 0000 = 0x0
 2239              		.loc 3 144 0
 2240 008a 2B68     		ldr	r3, [r5]
 2241 008c 23F0FF03 		bic	r3, r3, #255
 2242 0090 2B60     		str	r3, [r5]
 145:main.c        **** 				GPIOB_ODR	|= ( 0x9 << 4 );	// PA5,4,3,2 = 0110 = 0x6				
 2243              		.loc 3 145 0
 2244 0092 2B68     		ldr	r3, [r5]
 2245 0094 43F09003 		orr	r3, r3, #144
 2246 0098 2B60     		str	r3, [r5]
 146:main.c        **** 				break;
 2247              		.loc 3 146 0
 2248 009a BAE7     		b	.L253
 2249              	.L255:
 133:main.c        **** 				printf("turn left\n");
 2250              		.loc 3 133 0
 2251 009c 0F48     		ldr	r0, .L265+40
 2252 009e B847     		blx	r7
 2253              	.LVL234:
 136:main.c        **** 				GPIOB_ODR	&= (~0xf << 4 );	// PA5,4,3,2 = 0000 = 0x0
 2254              		.loc 3 136 0
 2255 00a0 2B68     		ldr	r3, [r5]
 2256 00a2 23F0FF03 		bic	r3, r3, #255
 2257 00a6 2B60     		str	r3, [r5]
 137:main.c        **** 				GPIOB_ODR	|= ( 0x6 << 4 );	// PA5,4,3,2 = 1001 = 0x9
 2258              		.loc 3 137 0
 2259 00a8 2B68     		ldr	r3, [r5]
 2260 00aa 43F06003 		orr	r3, r3, #96
 2261 00ae 2B60     		str	r3, [r5]
 138:main.c        **** 				break;
 2262              		.loc 3 138 0
 2263 00b0 AFE7     		b	.L253
 2264              	.L266:
 2265 00b2 00BF     		.align	2
 2266              	.L265:
 2267 00b4 00000000 		.word	.LC0
 2268 00b8 00000000 		.word	printf
 2269 00bc 00000000 		.word	init_TIM3
 2270 00c0 00380140 		.word	1073821696
 2271 00c4 04380140 		.word	1073821700
 2272 00c8 0C0C0140 		.word	1073810444
 2273 00cc 38000000 		.word	.LC5
 2274 00d0 18000000 		.word	.LC2
 2275 00d4 0C000000 		.word	.LC1
 2276 00d8 2C000000 		.word	.LC4
 2277 00dc 20000000 		.word	.LC3
 2278              		.cfi_endproc
 2279              	.LFE17:
 2281              		.section	.rodata.str1.4,"aMS",%progbits,1
 2282              		.align	2
 2283              	.LC0:
 2284 0000 4D6F726F 		.ascii	"Moror_Ctrl\012\000"
 2284      725F4374 
 2284      726C0A00 
 2285              	.LC1:
 2286 000c 666F7277 		.ascii	"forward\012\000"
 2286      6172640A 
 2286      00
 2287 0015 000000   		.space	3
 2288              	.LC2:
 2289 0018 6261636B 		.ascii	"back\012\000"
 2289      0A00
 2290 001e 0000     		.space	2
 2291              	.LC3:
 2292 0020 7475726E 		.ascii	"turn left\012\000"
 2292      206C6566 
 2292      740A00
 2293 002b 00       		.space	1
 2294              	.LC4:
 2295 002c 7475726E 		.ascii	"turn right\012\000"
 2295      20726967 
 2295      68740A00 
 2296              	.LC5:
 2297 0038 73746F70 		.ascii	"stop\012\000"
 2297      0A00
 2298 003e 0000     		.text
 2299              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:19     .text.print_byte:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:24     .text.print_byte:00000000 print_byte
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:67     .text.print_byte:00000020 $d
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:73     .text.get_byte:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:78     .text.get_byte:00000000 get_byte
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:101    .text.get_byte:00000010 $d
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:107    .text.SerialOutputString:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:112    .text.SerialOutputString:00000000 SerialOutputString
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:167    .text.SerialOutputString:0000002c $d
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:172    .text.StrNCmp:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:177    .text.StrNCmp:00000000 StrNCmp
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:243    .text.StrCmp:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:248    .text.StrCmp:00000000 StrCmp
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:314    .text.DecToLong:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:319    .text.DecToLong:00000000 DecToLong
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:405    .text.printf:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:410    .text.printf:00000000 printf
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:1051   .text.printf:00000310 $d
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:1057   .text.printf:00000320 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:1378   .text.delay_us:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:1383   .text.delay_us:00000000 delay_us
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:1671   .text.delay_ms:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:1676   .text.delay_ms:00000000 delay_ms
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:1984   .text.init_TIM3:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:1989   .text.init_TIM3:00000000 init_TIM3
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2061   .text.init_TIM3:00000054 $d
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2070   .text.change_duty31:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2075   .text.change_duty31:00000000 change_duty31
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2092   .text.change_duty31:00000008 $d
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2097   .text.change_duty32:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2102   .text.change_duty32:00000000 change_duty32
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2119   .text.change_duty32:00000008 $d
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2124   .text.startup.main:00000000 $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2129   .text.startup.main:00000000 main
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2184   .text.startup.main:00000028 $d
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2195   .text.startup.main:0000004c $t
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2267   .text.startup.main:000000b4 $d
C:\Users\AI02\AppData\Local\Temp\ccMrg62D.s:2282   .rodata.str1.4:00000000 $d
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
